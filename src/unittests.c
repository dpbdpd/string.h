/*
 * DO NOT EDIT THIS FILE. Generated by checkmk.
 * Edit the original source file "tests/_unittests.check" instead.
 */

#include <check.h>
#include <stdio.h>
#include <string.h>

#include "s21_string.h"

#define S21_TOL 0.001

#if defined(__linux__)
#define SUM_ERRORS 134

#elif defined(__APPLE__)
#define SUM_ERRORS 107
#endif

START_TEST(count_digits1) {
  // Testing the handling of a regular positive number
  int digitsBefore1, digitsAfter1;
  count_digits(123.456L, &digitsBefore1, &digitsAfter1);
  ck_assert_int_eq(digitsBefore1, 3);
  ck_assert_int_eq(digitsAfter1, 14);
}
END_TEST

START_TEST(count_digits2) {
  // Testing the handling of a positive number where the fractional part is less
  // than 1
  int digitsBefore2, digitsAfter2;
  count_digits(1000.5L, &digitsBefore2, &digitsAfter2);
  ck_assert_int_eq(digitsBefore2, 4);
  ck_assert_int_eq(digitsAfter2, 14);
}
END_TEST

START_TEST(count_digits3) {
  // Testing the handling of a number less than 1, containing 5 digits after the
  // decimal point
  int digitsBefore3, digitsAfter3;
  count_digits(0.99999L, &digitsBefore3, &digitsAfter3);
  ck_assert_int_eq(digitsBefore3, 0);
  ck_assert_int_eq(digitsAfter3, 14);
}
END_TEST

START_TEST(count_digits4) {
  // Testing the handling of a negative number
  int digitsBefore4, digitsAfter4;
  count_digits(-987654.321L, &digitsBefore4, &digitsAfter4);
  ck_assert_int_eq(digitsBefore4, 6);
  ck_assert_int_eq(digitsAfter4, 14);
}
END_TEST

START_TEST(double_to_str1) {
  // Check base numbers
  long double num1 = 12345.6789;
  char str1[S21_MAX] = "";
  int length1 = 4;
  int maxSize1 = S21_MAX;
  char test1[S21_MAX] = "12345.6789";
  util_double_to_str(num1, str1, &length1, maxSize1);
  ck_assert_str_eq(str1, test1);
}
END_TEST

START_TEST(double_to_str2) {
  // Check bigger length
  long double num2 = 1234.5678;
  char str2[S21_MAX] = "";
  int length2 = 5;
  int maxSize2 = S21_MAX;
  char test2[S21_MAX] = "1234.56780";
  util_double_to_str(num2, str2, &length2, maxSize2);
  ck_assert_str_eq(str2, test2);
}
END_TEST

START_TEST(double_to_str3) {
  // Check smaller length
  long double num3 = 12345.6789;
  char str3[S21_MAX] = "";
  int length3 = 2;
  int maxSize3 = S21_MAX;
  char test3[S21_MAX] = "12345.68";
  util_double_to_str(num3, str3, &length3, maxSize3);
  ck_assert_str_eq(str3, test3);
}
END_TEST

START_TEST(double_to_str4) {
  // Check string with words
  long double num4 = 12345.6789;
  char str4[S21_MAX] = "HI";
  int length4 = 4;
  int maxSize4 = S21_MAX;
  char test4[S21_MAX] = "HI12345.6789";
  util_double_to_str(num4, str4, &length4, maxSize4);
  ck_assert_str_eq(str4, test4);
}
END_TEST

START_TEST(double_to_str5) {
  // Check 0 length
  long double num5 = 12345.6789;
  char str5[S21_MAX] = "";
  int length5 = 0;
  int maxSize5 = S21_MAX;
  char test5[S21_MAX] = "12345";
  util_double_to_str(num5, str5, &length5, maxSize5);
  ck_assert_str_eq(str5, test5);
}
END_TEST

START_TEST(double_to_str6) {
  // Check negative number
  long double num6 = -12345.6789;
  char str6[S21_MAX] = "";
  int length6 = 4;
  int maxSize6 = S21_MAX;
  char test6[S21_MAX] = "-12345.6789";
  util_double_to_str(num6, str6, &length6, maxSize6);
  ck_assert_str_eq(str6, test6);
}
END_TEST

START_TEST(find_exponent1) {
  // Testing the handling of a regular positive number
  int exponentPower1;
  char exponentSign1;
  double result1 = find_exponent(123.456, &exponentPower1, &exponentSign1);
  ck_assert_double_eq_tol(result1, 1.23456, 0.00001);
  ck_assert_int_eq(exponentPower1, 2);
  ck_assert_int_eq(exponentSign1, '\0');
}
END_TEST

START_TEST(find_exponent2) {
  // Testing the handling of a number where the fractional part is less than 1
  int exponentPower2;
  char exponentSign2;
  double result2 = find_exponent(0.005, &exponentPower2, &exponentSign2);
  ck_assert_double_eq_tol(result2, 5.0, 0.00001);
  ck_assert_int_eq(exponentPower2, -3);
  ck_assert_int_eq(exponentSign2, '-');
}
END_TEST

START_TEST(find_exponent3) {
  // Testing the handling of a number less than 1, but more than 0
  int exponentPower3;
  char exponentSign3;
  double result3 = find_exponent(0.12345, &exponentPower3, &exponentSign3);
  ck_assert_double_eq_tol(result3, 1.2345, 0.00001);
  ck_assert_int_eq(exponentPower3, -1);
  ck_assert_int_eq(exponentSign3, '-');
}
END_TEST

START_TEST(find_exponent4) {
  // Testing the handling of a negative number
  int exponentPower4;
  char exponentSign4;
  double result4 = find_exponent(-9876.54321, &exponentPower4, &exponentSign4);
  ck_assert_double_eq_tol(result4, 9.87654321, 0.00001);
  ck_assert_int_eq(exponentPower4, 3);
  ck_assert_int_eq(exponentSign4, '\0');
}
END_TEST

START_TEST(hex_to_dec1) {
  // Checks if the function correctly converts the character '0' to its decimal
  // value '0'.
  ck_assert_int_eq(util_hex_to_dec('0'), 0);
}
END_TEST

START_TEST(hex_to_dec2) {
  // Checks if the function correctly converts the character '1' to its decimal
  // value '1'.
  ck_assert_int_eq(util_hex_to_dec('1'), 1);
}
END_TEST

START_TEST(hex_to_dec3) {
  // Checks if the function correctly converts the character '9' to its decimal
  // value '9'.
  ck_assert_int_eq(util_hex_to_dec('9'), 9);
}
END_TEST

START_TEST(hex_to_dec4) {
  // Checks if the function correctly converts the character 'A' to its decimal
  // value '10'.
  ck_assert_int_eq(util_hex_to_dec('A'), 10);
}
END_TEST

START_TEST(hex_to_dec5) {
  // Checks if the function correctly converts the character 'F' to its decimal
  // value '15'.
  ck_assert_int_eq(util_hex_to_dec('F'), 15);
}
END_TEST

START_TEST(hex_to_dec6) {
  // Checks if the function correctly converts the lowercase character 'a' to
  // its decimal value '10'.
  ck_assert_int_eq(util_hex_to_dec('a'), 10);
}
END_TEST

START_TEST(hex_to_dec7) {
  // Checks if the function correctly converts the lowercase character 'f' to
  // its decimal value '15'.
  ck_assert_int_eq(util_hex_to_dec('f'), 15);
}
END_TEST

START_TEST(hex_to_dec8) {
  // Checks if the function correctly handles a non-hexadecimal character ('g')
  // by returning '-1'.
  ck_assert_int_eq(util_hex_to_dec('g'), -1);
}
END_TEST

START_TEST(insert1) {
  // Inserting a string in the middle of the source string
  char s1[S21_MAX] = "abcdefghij";
  char s3[] = "\'I WAS HERE\'";
  char s4[] = "abc\'I WAS HERE\'defghij";
  s21_size_t num = 3;
  char *result = s21_insert(s1, s3, num);
  ck_assert_pstr_eq(s4, result);
  if (result) {
    free(result);
  }
}
END_TEST

START_TEST(insert2) {
  // Insert in the middle
  char *basket = "honer";
  char *ball = "meow";
  size_t st_ind = 2;
  char *result = s21_insert(basket, ball, st_ind);
  ck_assert_str_eq(result, "homeowner");
  if (result) {
    free(result);
  }
}
END_TEST

START_TEST(insert3) {
  // Insert in the beginning
  char *basket = "Bond";
  char *ball = "James ";
  size_t st_ind = 0;
  char *result = s21_insert(basket, ball, st_ind);
  ck_assert_str_eq(result, "James Bond");
  if (result) {
    free(result);
  }
}
END_TEST

START_TEST(insert4) {
  // Insert in the end
  char *basket = "basket";
  char *ball = "ball";
  size_t st_ind = 6;
  char *result = s21_insert(basket, ball, st_ind);
  ck_assert_str_eq(result, "basketball");
  if (result) {
    free(result);
  }
}
END_TEST

START_TEST(insert5) {
  // Insert an empty string
  char *basket = "School 21";
  char *ball = "";
  size_t st_ind = 6;
  char *result = s21_insert(basket, ball, st_ind);
  ck_assert_str_eq(result, basket);
  if (result) {
    free(result);
  }
}
END_TEST

START_TEST(insert6) {
  // Insert at invalid index
  char *basket = "School 21";
  char *ball = "Sber";
  size_t st_ind = 50;
  char *exp_result = NULL;
  char *result = s21_insert(basket, ball, st_ind);
  ck_assert_ptr_eq(result, exp_result);
}
END_TEST

START_TEST(insert7) {
  // Inserting  in the middle
  const char *src4 = "abcde";
  const char *str4 = "XYZ";
  size_t start_index4 = 2;
  char *expected4 = "abXYZcde";
  char *result = s21_insert(src4, str4, start_index4);
  ck_assert_str_eq(result, expected4);
  if (result) {
    free(result);
  }
}
END_TEST

START_TEST(insert8) {
  // Inserting a string at the end of the source string (boundary case)
  const char *src5 = "";
  const char *str5 = "hello";
  size_t start_index5 = 0;
  char *expected5 = "hello";
  char *result = s21_insert(src5, str5, start_index5);
  ck_assert_str_eq(result, expected5);
  if (result) {
    free(result);
  }
}
END_TEST

START_TEST(insert9) {
  // Inserting into a null source string
  const char *src1 = NULL;
  const char *str1 = "hello";
  size_t start_index1 = 0;
  ck_assert_ptr_eq(s21_insert(src1, str1, start_index1), NULL);
}
END_TEST

START_TEST(insert10) {
  // Inserting a null string into the source string
  const char *src2 = "world";
  const char *str2 = NULL;
  size_t start_index2 = 0;
  ck_assert_ptr_eq(s21_insert(src2, str2, start_index2), NULL);
}
END_TEST

START_TEST(insert11) {
  // Inserting into both null source string and null string
  const char *src3 = NULL;
  const char *str3 = NULL;
  size_t start_index3 = 0;
  ck_assert_ptr_eq(s21_insert(src3, str3, start_index3), NULL);
}
END_TEST

START_TEST(itoa1) {
  // Tests if the function returns NULL for unsupported base
  char str1[S21_MAX];
  ck_assert_ptr_eq(util_itoa(12345, str1, 1), NULL);
}
END_TEST

START_TEST(itoa2) {
  // Check the conversion of an integer into a binary string
  char str[S21_MAX];
  char test[S21_MAX] = "11000000111001";
  ck_assert_str_eq(util_itoa(12345, str, 2), test);
}
END_TEST

START_TEST(itoa3) {
  // Check the conversion of an integer into a binary string
  char str[S21_MAX];
  char test[S21_MAX] = "121221020";
  ck_assert_str_eq(util_itoa(12345, str, 3), test);
}
END_TEST

START_TEST(itoa4) {
  // Check the conversion of an integer into a binary string
  char str[S21_MAX];
  char test[S21_MAX] = "3000321";
  ck_assert_str_eq(util_itoa(12345, str, 4), test);
}
END_TEST

START_TEST(itoa5) {
  // Check the conversion of an integer into a binary string
  char str[S21_MAX];
  char test[S21_MAX] = "343340";
  ck_assert_str_eq(util_itoa(12345, str, 5), test);
}
END_TEST

START_TEST(itoa6) {
  // Check the conversion of an integer into a binary string
  char str[S21_MAX];
  char test[S21_MAX] = "133053";
  ck_assert_str_eq(util_itoa(12345, str, 6), test);
}
END_TEST

START_TEST(itoa7) {
  // Check the conversion of an integer into a binary string
  char str[S21_MAX];
  char test[S21_MAX] = "50664";
  ck_assert_str_eq(util_itoa(12345, str, 7), test);
}
END_TEST

START_TEST(itoa8) {
  // Check the conversion of an integer into a binary string
  char str[S21_MAX];
  char test[S21_MAX] = "30071";
  ck_assert_str_eq(util_itoa(12345, str, 8), test);
}
END_TEST

START_TEST(itoa9) {
  // Check the conversion of an integer into a binary string
  char str[S21_MAX];
  char test[S21_MAX] = "17836";
  ck_assert_str_eq(util_itoa(12345, str, 9), test);
}
END_TEST

START_TEST(itoa10) {
  // Check the conversion of an integer into a binary string
  char str[S21_MAX];
  char test[S21_MAX] = "12345";
  ck_assert_str_eq(util_itoa(12345, str, 10), test);
}
END_TEST

START_TEST(itoa11) {
  // Check the conversion of an integer into a binary string
  char str[S21_MAX];
  char test[S21_MAX] = "9303";
  ck_assert_str_eq(util_itoa(12345, str, 11), test);
}
END_TEST

START_TEST(itoa12) {
  // Check the conversion of an integer into a binary string
  char str[S21_MAX];
  char test[S21_MAX] = "7189";
  ck_assert_str_eq(util_itoa(12345, str, 12), test);
}
END_TEST

START_TEST(itoa13) {
  // Check the conversion of an integer into a binary string
  char str[S21_MAX];
  char test[S21_MAX] = "5808";
  ck_assert_str_eq(util_itoa(12345, str, 13), test);
}
END_TEST

START_TEST(itoa14) {
  // Check the conversion of an integer into a binary string
  char str[S21_MAX];
  char test[S21_MAX] = "46DB";
  ck_assert_str_eq(util_itoa(12345, str, 14), test);
}
END_TEST

START_TEST(itoa15) {
  // Check the conversion of an integer into a binary string
  char str[S21_MAX];
  char test[S21_MAX] = "39D0";
  ck_assert_str_eq(util_itoa(12345, str, 15), test);
}
END_TEST

START_TEST(itoa16) {
  // Check the conversion of an integer into a binary string
  char str[S21_MAX];
  char test[S21_MAX] = "3039";
  ck_assert_str_eq(util_itoa(12345, str, 16), test);
}
END_TEST

START_TEST(itoa17) {
  // Check the conversion of an integer into a binary string
  char str[S21_MAX];
  char test[S21_MAX] = "28C3";
  ck_assert_str_eq(util_itoa(12345, str, 17), test);
}
END_TEST

START_TEST(itoa18) {
  // Check the conversion of an integer into a binary string
  char str[S21_MAX];
  char test[S21_MAX] = "221F";
  ck_assert_str_eq(util_itoa(12345, str, 18), test);
}
END_TEST

START_TEST(itoa19) {
  // Check the conversion of an integer into a binary string
  char str[S21_MAX];
  char test[S21_MAX] = "1F3E";
  ck_assert_str_eq(util_itoa(12345, str, 19), test);
}
END_TEST

START_TEST(itoa20) {
  // Check the conversion of an integer into a binary string
  char str[S21_MAX];
  char test[S21_MAX] = "1AH5";
  ck_assert_str_eq(util_itoa(12345, str, 20), test);
}
END_TEST

START_TEST(itoa21) {
  // Check the conversion of an integer into a binary string
  char str[S21_MAX];
  char test[S21_MAX] = "16KI";
  ck_assert_str_eq(util_itoa(12345, str, 21), test);
}
END_TEST

START_TEST(itoa22) {
  // Check the conversion of an integer into a binary string
  char str[S21_MAX];
  char test[S21_MAX] = "13B3";
  ck_assert_str_eq(util_itoa(12345, str, 22), test);
}
END_TEST

START_TEST(itoa23) {
  // Check the conversion of an integer into a binary string
  char str[S21_MAX];
  char test[S21_MAX] = "107H";
  ck_assert_str_eq(util_itoa(12345, str, 23), test);
}
END_TEST

START_TEST(itoa24) {
  // Check the conversion of an integer into a binary string
  char str[S21_MAX];
  char test[S21_MAX] = "LA9";
  ck_assert_str_eq(util_itoa(12345, str, 24), test);
}
END_TEST

START_TEST(itoa25) {
  // Check the conversion of an integer into a binary string
  char str[S21_MAX];
  char test[S21_MAX] = "JIK";
  ck_assert_str_eq(util_itoa(12345, str, 25), test);
}
END_TEST

START_TEST(itoa26) {
  // Check the conversion of an integer into a binary string
  char str[S21_MAX];
  char test[S21_MAX] = "I6L";
  ck_assert_str_eq(util_itoa(12345, str, 26), test);
}
END_TEST

START_TEST(itoa27) {
  // Check the conversion of an integer into a binary string
  char str[S21_MAX];
  char test[S21_MAX] = "GP6";
  ck_assert_str_eq(util_itoa(12345, str, 27), test);
}
END_TEST

START_TEST(itoa28) {
  // Check the conversion of an integer into a binary string
  char str[S21_MAX];
  char test[S21_MAX] = "FKP";
  ck_assert_str_eq(util_itoa(12345, str, 28), test);
}
END_TEST

START_TEST(itoa29) {
  // Check the conversion of an integer into a binary string
  char str[S21_MAX];
  char test[S21_MAX] = "EJK";
  ck_assert_str_eq(util_itoa(12345, str, 29), test);
}
END_TEST

START_TEST(itoa30) {
  // Check the conversion of an integer into a binary string
  char str[S21_MAX];
  char test[S21_MAX] = "DLF";
  ck_assert_str_eq(util_itoa(12345, str, 30), test);
}
END_TEST

START_TEST(itoa31) {
  // Check the conversion of an integer into a binary string
  char str[S21_MAX];
  char test[S21_MAX] = "CQ7";
  ck_assert_str_eq(util_itoa(12345, str, 31), test);
}
END_TEST

START_TEST(itoa32) {
  // Check the conversion of an integer into a binary string
  char str[S21_MAX];
  char test[S21_MAX] = "C1P";
  ck_assert_str_eq(util_itoa(12345, str, 32), test);
}
END_TEST

START_TEST(itoa33) {
  // Check the conversion of an integer into a binary string
  char str[S21_MAX];
  char test[S21_MAX] = "BB3";
  ck_assert_str_eq(util_itoa(12345, str, 33), test);
}
END_TEST

START_TEST(itoa34) {
  // Check the conversion of an integer into a binary string
  char str[S21_MAX];
  char test[S21_MAX] = "AN3";
  ck_assert_str_eq(util_itoa(12345, str, 34), test);
}
END_TEST

START_TEST(itoa35) {
  // Check the conversion of an integer into a binary string
  char str[S21_MAX];
  char test[S21_MAX] = "A2P";
  ck_assert_str_eq(util_itoa(12345, str, 35), test);
}
END_TEST

START_TEST(itoa36) {
  // Check the conversion of an integer into a binary string
  char str[S21_MAX];
  char test[S21_MAX] = "9IX";
  ck_assert_str_eq(util_itoa(12345, str, 36), test);
}
END_TEST

START_TEST(memchr1) {
  // Check used symbol
  char str1[S21_MAX] = "Hello, world!";
  char c1 = 'w';
  ck_assert_pstr_eq(memchr(str1, c1, S21_MAX), s21_memchr(str1, c1, S21_MAX));
}
END_TEST

START_TEST(memchr2) {
  // Check unused symbol
  char str2[S21_MAX] = "Hello, world!";
  char c2 = 'P';
  ck_assert_pstr_eq(memchr(str2, c2, S21_MAX), s21_memchr(str2, c2, S21_MAX));
}
END_TEST

START_TEST(memchr3) {
  // Check empty string
  char str3[S21_MAX] = "";
  char c3 = 'H';
  ck_assert_pstr_eq(memchr(str3, c3, S21_MAX), s21_memchr(str3, c3, S21_MAX));
}
END_TEST

START_TEST(memchr4) {
  // Check space symbol
  char str4[S21_MAX] = "Hello, world!";
  char c4 = ' ';
  ck_assert_pstr_eq(memchr(str4, c4, S21_MAX), s21_memchr(str4, c4, S21_MAX));
}
END_TEST

START_TEST(memchr5) {
  // Check empty string and space symbol
  char str5[S21_MAX] = "";
  char c5 = ' ';
  ck_assert_pstr_eq(memchr(str5, c5, S21_MAX), s21_memchr(str5, c5, S21_MAX));
}
END_TEST

START_TEST(memchr6) {
  // Check NULL string
  char *str6 = NULL;
  char c6 = 'w';
  ck_assert_pstr_eq(s21_memchr(str6, c6, S21_MAX), NULL);
}
END_TEST

START_TEST(memchr7) {
  // Check terminal null
  char str7[S21_MAX] = "Hello, world!";
  char c7 = '\0';
  ck_assert_pstr_eq(memchr(str7, c7, S21_MAX), s21_memchr(str7, c7, S21_MAX));
}
END_TEST

START_TEST(memchr8) {
  // Check NULL string and terminal null
  char *str8 = NULL;
  char c8 = '\0';
  ck_assert_pstr_eq(s21_memchr(str8, c8, S21_MAX), NULL);
}
END_TEST

START_TEST(memchr9) {
  // Check path of string
  char str9[S21_MAX] = "Hello, world!";
  char c9 = 'w';
  ck_assert_pstr_eq(memchr(str9, c9, 5), s21_memchr(str9, c9, 5));
}
END_TEST

START_TEST(memchr10) {
  // Check 0 bytes
  char str10[S21_MAX] = "Hello, world!";
  char c10 = 'H';
  ck_assert_pstr_eq(memchr(str10, c10, 0), s21_memchr(str10, c10, 0));
}
END_TEST

START_TEST(memcmp1) {
  // Strings have same symbols
  char str1[S21_MAX] = "Hello, world!";
  char substr1[S21_MAX] = "Hello, world!";
  ck_assert_int_eq(memcmp(str1, substr1, S21_MAX),
                   s21_memcmp(str1, substr1, S21_MAX));
}
END_TEST

START_TEST(memcmp2) {
  // Strings have different words
  char str2[S21_MAX] = "Hello, world!";
  char substr2[S21_MAX] = "Hello, Earth!";
  ck_assert_int_eq(memcmp(str2, substr2, S21_MAX),
                   s21_memcmp(str2, substr2, S21_MAX));
}
END_TEST

START_TEST(memcmp3) {
  // Strings have different symbols
  char str3[S21_MAX] = "Hello, world!";
  char substr3[S21_MAX] = "Hello, World!";
  ck_assert_int_eq(memcmp(str3, substr3, S21_MAX),
                   s21_memcmp(str3, substr3, S21_MAX));
}
END_TEST

START_TEST(memcmp4) {
  // First string is empty
  char str4[S21_MAX] = "";
  char substr4[S21_MAX] = "Hello";
  ck_assert_int_eq(memcmp(str4, substr4, S21_MAX),
                   s21_memcmp(str4, substr4, S21_MAX));
}
END_TEST

START_TEST(memcmp5) {
  // Second string is empty
  char str5[S21_MAX] = "Hello, world!";
  char substr5[S21_MAX] = "";
  ck_assert_int_eq(memcmp(str5, substr5, S21_MAX),
                   s21_memcmp(str5, substr5, S21_MAX));
}
END_TEST

START_TEST(memcmp6) {
  // Check path of string
  char str6[S21_MAX] = "Hello, world!";
  char substr6[S21_MAX] = "Hello, World!";
  ck_assert_int_eq(memcmp(str6, substr6, 6), s21_memcmp(str6, substr6, 6));
}
END_TEST

START_TEST(memcmp7) {
  // Check without check
  char str7[S21_MAX] = "Hello, world!";
  char substr7[S21_MAX] = "Hello";
  ck_assert_int_eq(memcmp(str7, substr7, 0), s21_memcmp(str7, substr7, 0));
}
END_TEST

START_TEST(memcmp8) {
  // Check same numbers string
  char str8[S21_MAX] = "12345786439";
  char substr8[S21_MAX] = "12345786439";
  ck_assert_int_eq(memcmp(str8, substr8, S21_MAX),
                   s21_memcmp(str8, substr8, S21_MAX));
}
END_TEST

START_TEST(memcmp9) {
  // Check different numbers string
  char str9[S21_MAX] = "12345786439";
  char substr9[S21_MAX] = "1234439";
  ck_assert_int_eq(memcmp(str9, substr9, S21_MAX),
                   s21_memcmp(str9, substr9, S21_MAX));
}
END_TEST

START_TEST(memcmp10) {
  // Check path of numbers string
  char str10[S21_MAX] = "12345786439";
  char substr10[S21_MAX] = "1234439";
  ck_assert_int_eq(memcmp(str10, substr10, 4), s21_memcmp(str10, substr10, 4));
}
END_TEST

START_TEST(memcpy1) {
  // Copy simple word
  char str1[S21_MAX] = "Hello, world!";
  char substr1[S21_MAX] = "World";
  ck_assert_pstr_eq(memcpy(str1, substr1, 5), s21_memcpy(str1, substr1, 5));
}
END_TEST

START_TEST(memcpy2) {
  // Copy more bytes
  char str2[S21_MAX] = "Hello, world!";
  char substr2[S21_MAX] = "Bonjour";
  ck_assert_pstr_eq(memcpy(str2, substr2, 13), s21_memcpy(str2, substr2, 13));
}
END_TEST

START_TEST(memcpy3) {
  // Copy part of the substring
  char str3[S21_MAX] = "Hello, world!";
  char substr3[S21_MAX] = "Bonjour, world";
  ck_assert_pstr_eq(memcpy(str3, substr3, 7), s21_memcpy(str3, substr3, 7));
}
END_TEST

START_TEST(memcpy4) {
  // Empty string as the haystack
  char str4[S21_MAX] = "";
  char substr4[S21_MAX] = "Hello, world!";
  ck_assert_pstr_eq(memcpy(str4, substr4, 13), s21_memcpy(str4, substr4, 13));
}
END_TEST

START_TEST(memcpy5) {
  // Empty string as the needle
  char str5[S21_MAX] = "Hello, world!";
  char substr5[S21_MAX] = "";
  ck_assert_pstr_eq(memcpy(str5, substr5, 5), s21_memcpy(str5, substr5, 5));
}
END_TEST

START_TEST(memcpy6) {
  // Check big numbers of bytes
  char str6[S21_MAX] = "Hello, world!";
  char substr6[S21_MAX] = "school";
  ck_assert_pstr_eq(memcpy(str6, substr6, strlen(substr6)),
                    s21_memcpy(str6, substr6, strlen(substr6)));
}
END_TEST

START_TEST(memcpy7) {
  // NULL as the haystack
  char substr7[S21_MAX] = "world";
  ck_assert_ptr_eq(s21_memcpy(NULL, substr7, S21_MAX), NULL);
}
END_TEST

START_TEST(memcpy8) {
  // NULL as the needle
  char str8[S21_MAX] = "Hello, world!";
  char *substr8 = NULL;
  ck_assert_pstr_eq(s21_memcpy(str8, substr8, S21_MAX), NULL);
}
END_TEST

START_TEST(memcpy9) {
  // Both haystack and needle are NULL
  char *str9 = NULL;
  char *substr9 = NULL;
  ck_assert_pstr_eq(s21_memcpy(str9, substr9, S21_MAX), NULL);
}
END_TEST

START_TEST(memcpy10) {
  // Check 0 bytes
  char str10[S21_MAX] = "Hello, world!";
  char substr10[S21_MAX] = "Bonjour!";
  ck_assert_pstr_eq(memcpy(str10, substr10, 0), s21_memcpy(str10, substr10, 0));
}
END_TEST

START_TEST(memcpy11) {
  // Check 0 bytes and second string is NULL
  char str11[S21_MAX] = "Hello, world!";
  char *substr11 = NULL;
  ck_assert_pstr_eq(memcpy(str11, substr11, 0), s21_memcpy(str11, substr11, 0));
}
END_TEST

START_TEST(memset1) {
  // Check all string
  char str1[S21_MAX] = "Hello, world!";
  char c1 = 'w';
  ck_assert_pstr_eq(memset(str1, c1, 13), s21_memset(str1, c1, 13));
}
END_TEST

START_TEST(memset2) {
  // Check part of string
  char str2[S21_MAX] = "Hello, world!";
  char c2 = 'P';
  ck_assert_pstr_eq(memset(str2, c2, 6), s21_memset(str2, c2, 6));
}
END_TEST

START_TEST(memset3) {
  // Check empty string
  char str3[S21_MAX] = "";
  char c3 = 'H';
  ck_assert_pstr_eq(memset(str3, c3, 9), s21_memset(str3, c3, 9));
}
END_TEST

START_TEST(memset4) {
  // Check space symbol
  char str4[S21_MAX] = "Hello, world!";
  char c4 = ' ';
  ck_assert_pstr_eq(memset(str4, c4, 3), s21_memset(str4, c4, 3));
}
END_TEST

START_TEST(memset5) {
  // Check empty string and space symbol
  char str5[S21_MAX] = "";
  char c5 = ' ';
  ck_assert_pstr_eq(memset(str5, c5, 4), s21_memset(str5, c5, 4));
}
END_TEST

START_TEST(memset6) {
  // Check NULL string
  char *str6 = NULL;
  char c6 = 'w';
  ck_assert_pstr_eq(s21_memset(str6, c6, 4), NULL);
}
END_TEST

START_TEST(memset7) {
  // Check terminal null
  char str7[S21_MAX] = "Hello, world!";
  char c7 = '\0';
  ck_assert_pstr_eq(memset(str7, c7, 4), s21_memset(str7, c7, 4));
}
END_TEST

START_TEST(memset8) {
  // Check NULL string and terminal null
  char *str8 = NULL;
  char c8 = '\0';
  ck_assert_pstr_eq(s21_memset(str8, c8, 4), NULL);
}
END_TEST

START_TEST(memset9) {
  // Check big number of bytes
  char str9[S21_MAX] = "Hello, world!";
  char c9 = 'Q';
  ck_assert_pstr_eq(memset(str9, c9, 100), s21_memset(str9, c9, 100));
}
END_TEST

START_TEST(memset10) {
  // Check 0 bytes
  char str10[S21_MAX] = "Hello, world!";
  char c10 = 'Q';
  ck_assert_ptr_eq(str10, s21_memset(str10, c10, 0));
}
END_TEST

START_TEST(memset11) {
  // Check string with special characters
  char str11[S21_MAX] = "@#$%^&*()!~";
  char c11 = '^';
  ck_assert_pstr_eq(memset(str11, c11, 5), s21_memset(str11, c11, 5));
}
END_TEST

START_TEST(memset12) {
  // Check string with numerical characters
  char str12[S21_MAX] = "1234567890";
  char c12 = '9';
  ck_assert_pstr_eq(memset(str12, c12, 5), s21_memset(str12, c12, 5));
}
END_TEST

START_TEST(memset13) {
  // Check string with mixed characters
  char str13[S21_MAX] = "Hello123$%^";
  char c13 = '%';
  ck_assert_pstr_eq(memset(str13, c13, 7), s21_memset(str13, c13, 7));
}
END_TEST

START_TEST(reverse1) {
  // Check basic string
  char str_hello[] = "Hello";
  ck_assert_str_eq(util_reverse(str_hello), "olleH");
}
END_TEST

START_TEST(reverse2) {
  // Check empty string
  char str_empty[S21_MAX] = "";
  ck_assert_str_eq(util_reverse(str_empty), str_empty);
}
END_TEST

START_TEST(reverse3) {
  // Check NULL string
  char *str_null = NULL;
  ck_assert_ptr_eq(util_reverse(str_null), NULL);
}
END_TEST

START_TEST(reverse4) {
  // Test util_reverse of a normal string.
  char str1[] = "hello";
  util_reverse(str1);
  ck_assert_str_eq(str1, "olleh");
}
END_TEST

START_TEST(reverse5) {
  // Test util_reverse of a string with a single character.
  char str_single_char[] = "a";
  util_reverse(str_single_char);
  ck_assert_str_eq(str_single_char, "a");
}
END_TEST

START_TEST(reverse6) {
  // Test util_reverse of a string with two characters.
  char str_two_chars[] = "ab";
  util_reverse(str_two_chars);
  ck_assert_str_eq(str_two_chars, "ba");
}
END_TEST

START_TEST(rounding_double1) {
  // Testing the rounding of a regular positive number
  char number1[] = "123.45678";
  s21_rounding_double(3, 2, number1);
  ck_assert_str_eq(number1, "123.46");
}
END_TEST

START_TEST(rounding_double2) {
  // Testing the rounding of a number where the fractional part is less than 1
  char number2[] = "0.00056";
  s21_rounding_double(1, 3, number2);
  ck_assert_str_eq(number2, "0.001");
}
END_TEST

START_TEST(rounding_double3) {
  // Testing the rounding of a number less than 1, but more than 0
  char number3[] = "0.12345";
  s21_rounding_double(2, 3, number3);
  ck_assert_str_eq(number3, "0.123");
}
END_TEST

START_TEST(rounding_double4) {
  // Testing the rounding of a negative number
  char number4[] = "-9876.54321";
  s21_rounding_double(6, 2, number4);
  ck_assert_str_eq(number4, "-9876.54");
}
END_TEST

START_TEST(rounding_double5) {
  // Testing rounding up of the number
  char number5[] = "123.4999";
  s21_rounding_double(4, 2, number5);
  ck_assert_str_eq(number5, "123.50");
}
END_TEST

START_TEST(rounding_double6) {
  // Testing zero precision rounding
  char number6[] = "123.45678";
  s21_rounding_double(4, 0, number6);
  ck_assert_str_eq(number6, "123");
}
END_TEST

START_TEST(rounding_double7) {
  // Testing rounding when precision is more than number's decimal part
  char number7[] = "123.4";
  s21_rounding_double(4, 4, number7);
  ck_assert_str_eq(number7, "123.4");
}
END_TEST

START_TEST(sprintf_spec_char1) {
  // Tests basic character formatting with a non-null character
  char buff[S21_MAX] = "";
  char buff2[S21_MAX] = "";
  char a = 'a';
  sprintf(buff, "Life is %c long lesson in humility. -James M. Barrie", a);
  s21_sprintf(buff2, "Life is %c long lesson in humility. -James M. Barrie", a);
  ck_assert_str_eq(buff, buff2);
}
END_TEST

START_TEST(sprintf_spec_char2) {
  // Tests character formatting with a null character '\0'
  char buff[S21_MAX] = "";
  char buff2[S21_MAX] = "";
  char a = '\0';
  sprintf(buff, "Life is %c long lesson in humility. -James M. Barrie", a);
  s21_sprintf(buff2, "Life is %c long lesson in humility. -James M. Barrie", a);
  ck_assert_str_eq(buff, buff2);
}
END_TEST

START_TEST(sprintf_spec_char3) {
  // Tests character formatting with left alignment flag
  char buff[S21_MAX] = "";
  char buff2[S21_MAX] = "";
  char a = 'a';
  sprintf(buff, "Life is %-5c long lesson in humility. -James M. Barrie", a);
  s21_sprintf(buff2, "Life is %-5c long lesson in humility. -James M. Barrie",
              a);
  ck_assert_str_eq(buff, buff2);
}
END_TEST

START_TEST(sprintf_spec_char4) {
  // Tests character formatting with field width
  char buff[S21_MAX] = "";
  char buff2[S21_MAX] = "";
  char a = 'a';
  sprintf(buff, "Life is %5c long lesson in humility. -James M. Barrie", a);
  s21_sprintf(buff2, "Life is %5c long lesson in humility. -James M. Barrie",
              a);
  ck_assert_str_eq(buff, buff2);
}
END_TEST

START_TEST(sprintf_spec_char5) {
  // Tests character formatting with field width and left alignment
  char buff[S21_MAX] = "";
  char buff2[S21_MAX] = "";
  char a = 'a';
  sprintf(buff, "Life is %-5c long lesson in humility. -James M. Barrie", a);
  s21_sprintf(buff2, "Life is %-5c long lesson in humility. -James M. Barrie",
              a);
  ck_assert_str_eq(buff, buff2);
}
END_TEST

START_TEST(sprintf_spec_double1) {
  // Testing basic formatting of a large decimal number
  double x1 = -332483472728.4579;
  char buff1_1[5000] = "";
  char buff1_2[5000] = "";
  sprintf(buff1_1, "%f", x1);
  s21_sprintf(buff1_2, "%f", x1);
  ck_assert_str_eq(buff1_1, buff1_2);
}
END_TEST

START_TEST(sprintf_spec_double2) {
  // Testing formatting with width (no precision)
  double x1 = -332483472728.4579;
  char buff2_1[5000] = "";
  char buff2_2[5000] = "";
  sprintf(buff2_1, "%5.f", x1);
  s21_sprintf(buff2_2, "%5.f", x1);
  ck_assert_str_eq(buff2_1, buff2_2);
}
END_TEST

START_TEST(sprintf_spec_double3) {
  // Testing formatting without width (default precision)
  double x1 = -332483472728.4579;
  char buff3_1[5000] = "";
  char buff3_2[5000] = "";
  sprintf(buff3_1, "%5f", x1);
  s21_sprintf(buff3_2, "%5f", x1);
  ck_assert_str_eq(buff3_1, buff3_2);
}
END_TEST

START_TEST(sprintf_spec_double4) {
  // Testing formatting without width, precision specified
  double x1 = -332483472728.4579;
  char buff4_1[5000] = "";
  char buff4_2[5000] = "";
  sprintf(buff4_1, "%.5f", x1);
  s21_sprintf(buff4_2, "%.5f", x1);
  ck_assert_str_eq(buff4_1, buff4_2);
}
END_TEST

START_TEST(sprintf_spec_double5) {
  // Testing formatting with width and precision
  double x1 = -332483472728.4579;
  char buff5_1[5000] = "";
  char buff5_2[5000] = "";
  sprintf(buff5_1, "%5.5f", x1);
  s21_sprintf(buff5_2, "%5.5f", x1);
  ck_assert_str_eq(buff5_1, buff5_2);
}
END_TEST

START_TEST(sprintf_spec_double6) {
  // Testing basic formatting of a long double
  long double x2 = -12.4579;
  char buff6_1[S21_MAX] = "";
  char buff6_2[S21_MAX] = "";
  sprintf(buff6_1, "%Lf", x2);
  s21_sprintf(buff6_2, "%Lf", x2);
  ck_assert_str_eq(buff6_1, buff6_2);
}
END_TEST

START_TEST(sprintf_spec_double7) {
  // Testing formatting with width and precision for long double
  long double x2 = -12.4579;
  char buff7_1[S21_MAX] = "";
  char buff7_2[S21_MAX] = "";
  sprintf(buff7_1, "%5.5Lf", x2);
  s21_sprintf(buff7_2, "%5.5Lf", x2);
  ck_assert_str_eq(buff7_1, buff7_2);
}
END_TEST

START_TEST(sprintf_spec_double8) {
  // Testing the use of the '*' specifier for dynamic width
  int s = 3;
  double x3 = -12.4579;
  char buff8_1[S21_MAX] = "";
  char buff8_2[S21_MAX] = "";
  sprintf(buff8_1, "%*.f", s, x3);
  s21_sprintf(buff8_2, "%*.f", s, x3);
  ck_assert_str_eq(buff8_1, buff8_2);
}
END_TEST

START_TEST(sprintf_spec_double9) {
  // Testing the use of the '*' specifier for dynamic precision
  int s = 3;
  double x3 = -12.4579;
  char buff9_1[S21_MAX] = "";
  char buff9_2[S21_MAX] = "";
  sprintf(buff9_1, "%5.*f", s, x3);
  s21_sprintf(buff9_2, "%5.*f", s, x3);
  ck_assert_str_eq(buff9_1, buff9_2);
}
END_TEST

START_TEST(sprintf_spec_double10) {
  // Testing basic formatting of a double number
  double num = 1.123456789;
  char buff10_1[S21_MAX] = "";
  char buff10_2[S21_MAX] = "";
  sprintf(buff10_1, "%lf", num);
  s21_sprintf(buff10_2, "%lf", num);
  ck_assert_str_eq(buff10_1, buff10_2);
}
END_TEST

START_TEST(sprintf_spec_double11) {
  // Testing formatting with precision for a simple double number
  double num = 1.123456789;
  char buff11_1[S21_MAX] = "";
  char buff11_2[S21_MAX] = "";
  sprintf(buff11_1, "%.4lf", num);
  s21_sprintf(buff11_2, "%.4lf", num);
  ck_assert_str_eq(buff11_1, buff11_2);
}
END_TEST

START_TEST(sprintf_spec_double12) {
  // Testing formatting with field width for a simple double number
  double num = 1.123456789;
  char buff12_1[S21_MAX] = "";
  char buff12_2[S21_MAX] = "";
  sprintf(buff12_1, "%20lf", num);
  s21_sprintf(buff12_2, "%20lf", num);
  ck_assert_str_eq(buff12_1, buff12_2);
}
END_TEST

START_TEST(sprintf_spec_exponent1) {
  // Test default exponent format.
  double x = 12.4579;
  char buff[S21_MAX] = "";
  char buff2[S21_MAX] = "";
  sprintf(buff, "TEST1 %e", x);
  s21_sprintf(buff2, "TEST1 %e", x);
  ck_assert_str_eq(buff, buff2);
}
END_TEST

START_TEST(sprintf_spec_exponent2) {
  // Test zero-padded exponent format.
  double x = 12.4579;
  char buff[S21_MAX] = "";
  char buff2[S21_MAX] = "";
  sprintf(buff, "TEST2 %0e", x);
  s21_sprintf(buff2, "TEST2 %0e", x);
  ck_assert_str_eq(buff, buff2);
}
END_TEST

START_TEST(sprintf_spec_exponent3) {
  // Test space-prefixed positive number exponent format.
  double x = 12.4579;
  char buff[S21_MAX] = "";
  char buff2[S21_MAX] = "";
  sprintf(buff, "TEST3 % e", x);
  s21_sprintf(buff2, "TEST3 % e", x);
  ck_assert_str_eq(buff, buff2);
}
END_TEST

START_TEST(sprintf_spec_exponent4) {
  // Test left-justified exponent format
  double x = 12.4579;
  char buff[S21_MAX] = "";
  char buff2[S21_MAX] = "";
  sprintf(buff, "TEST4 %-e", x);
  s21_sprintf(buff2, "TEST4 %-e", x);
  ck_assert_str_eq(buff, buff2);
}
END_TEST

START_TEST(sprintf_spec_exponent5) {
  // Test sign-prefixed exponent format
  double x = 12.4579;
  char buff[S21_MAX] = "";
  char buff2[S21_MAX] = "";
  sprintf(buff, "TEST5 %+e", x);
  s21_sprintf(buff2, "TEST5 %+e", x);
  ck_assert_str_eq(buff, buff2);
}
END_TEST

START_TEST(sprintf_spec_exponent6) {
  // Test with specificator1 - Precision alone.
  double x = 12.4579;
  char buff[S21_MAX] = "";
  char buff2[S21_MAX] = "";
  sprintf(buff, "TEST6 %.e", x);
  s21_sprintf(buff2, "TEST6 %.e", x);
  ck_assert_str_eq(buff, buff2);
}
END_TEST

START_TEST(sprintf_spec_exponent7) {
  // Test with specificator1 - Width and e specifier.
  double x = 12.4579;
  char buff[S21_MAX] = "";
  char buff2[S21_MAX] = "";
  sprintf(buff, "TEST7 %5.e", x);
  s21_sprintf(buff2, "TEST7 %5.e", x);
  ck_assert_str_eq(buff, buff2);
}
END_TEST

START_TEST(sprintf_spec_exponent8) {
  // Test with specificator1 - Width alone.
  double x = 12.4579;
  char buff[S21_MAX] = "";
  char buff2[S21_MAX] = "";
  sprintf(buff, "TEST8 %5e", x);
  s21_sprintf(buff2, "TEST8 %5e", x);
  ck_assert_str_eq(buff, buff2);
}
END_TEST

START_TEST(sprintf_spec_exponent9) {
  // Test with specificator1 - Precision of 5.
  double x = 12.4579;
  char buff[S21_MAX] = "";
  char buff2[S21_MAX] = "";
  sprintf(buff, "TEST9 %.5e", x);
  s21_sprintf(buff2, "TEST9 %.5e", x);
  ck_assert_str_eq(buff, buff2);
}
END_TEST

START_TEST(sprintf_spec_exponent10) {
  // Test with specificator1 - Width of 5 and Precision of 5.
  double x = 12.4579;
  char buff[S21_MAX] = "";
  char buff2[S21_MAX] = "";
  sprintf(buff, "TEST10 %5.5e", x);
  s21_sprintf(buff2, "TEST10 %5.5e", x);
  ck_assert_str_eq(buff, buff2);
}
END_TEST

START_TEST(sprintf_spec_exponent11) {
  // Test with specificator2 and big number - Precision alone.
  double x = 122332483472728.4579;
  char buff[S21_MAX] = "";
  char buff2[S21_MAX] = "";
  sprintf(buff, "TEST11 %.e", x);
  s21_sprintf(buff2, "TEST11 %.e", x);
  ck_assert_str_eq(buff, buff2);
}
END_TEST

START_TEST(sprintf_spec_exponent12) {
  // Test with specificator2 and big number - Width and e specifier.
  double x = 122332483472728.4579;
  char buff[S21_MAX] = "";
  char buff2[S21_MAX] = "";
  sprintf(buff, "TEST12 %5.e", x);
  s21_sprintf(buff2, "TEST12 %5.e", x);
  ck_assert_str_eq(buff, buff2);
}
END_TEST

START_TEST(sprintf_spec_exponent13) {
  // Test with specificator2 and big number - Width alone.
  double x = 122332483472728.4579;
  char buff[S21_MAX] = "";
  char buff2[S21_MAX] = "";
  sprintf(buff, "TEST13 %5e", x);
  s21_sprintf(buff2, "TEST13 %5e", x);
  ck_assert_str_eq(buff, buff2);
}
END_TEST

START_TEST(sprintf_spec_exponent14) {
  // Test with specificator2 and big number - Precision of 5.
  double x = 122332483472728.4579;
  char buff[S21_MAX] = "";
  char buff2[S21_MAX] = "";
  sprintf(buff, "TEST14 %.5e", x);
  s21_sprintf(buff2, "TEST14 %.5e", x);
  ck_assert_str_eq(buff, buff2);
}
END_TEST

START_TEST(sprintf_spec_exponent15) {
  // Test with specificator2 and big number - Width of 5 and Precision of 5.
  double x = 122332483472728.4579;
  char buff[S21_MAX] = "";
  char buff2[S21_MAX] = "";
  sprintf(buff, "TEST15 %5.5e", x);
  s21_sprintf(buff2, "TEST15 %5.5e", x);
  ck_assert_str_eq(buff, buff2);
}
END_TEST

START_TEST(sprintf_spec_exponent16) {
  // Test with length specifier - Precision alone with long double.
  long double x = 12.4579;
  char buff[S21_MAX] = "";
  char buff2[S21_MAX] = "";
  sprintf(buff, "TEST16 %Le", x);
  s21_sprintf(buff2, "TEST16 %Le", x);
  ck_assert_str_eq(buff, buff2);
}
END_TEST

START_TEST(sprintf_spec_exponent17) {
  // Test with length specifier and width - Width and e specifier for long
  // double.
  long double x = 12.4579;
  char buff[S21_MAX] = "";
  char buff2[S21_MAX] = "";
  sprintf(buff, "TEST17 %5.Le", x);
  s21_sprintf(buff2, "TEST17 %5.Le", x);
  ck_assert_str_eq(buff, buff2);
}
END_TEST

START_TEST(sprintf_spec_exponent18) {
  // Test with length specifier - Width alone for long double.
  long double x = 12.4579;
  char buff[S21_MAX] = "";
  char buff2[S21_MAX] = "";
  sprintf(buff, "TEST18 %5Le", x);
  s21_sprintf(buff2, "TEST18 %5Le", x);
  ck_assert_str_eq(buff, buff2);
}
END_TEST

START_TEST(sprintf_spec_exponent19) {
  // Test with length specifier - Precision of 5 with long double.
  long double x = 12.4579;
  char buff[S21_MAX] = "";
  char buff2[S21_MAX] = "";
  sprintf(buff, "TEST19 %.5Le", x);
  s21_sprintf(buff2, "TEST19 %.5Le", x);
  ck_assert_str_eq(buff, buff2);
}
END_TEST

START_TEST(sprintf_spec_exponent20) {
  // Test with length specifier - Width of 5 and Precision of 5 with long
  // double.
  long double x = 12.4579;
  char buff[S21_MAX] = "";
  char buff2[S21_MAX] = "";
  sprintf(buff, "TEST20 %5.5Le", x);
  s21_sprintf(buff2, "TEST20 %5.5Le", x);
  ck_assert_str_eq(buff, buff2);
}
END_TEST

START_TEST(sprintf_spec_exponent21) {
  // Test combination of flags: plus, minus, and '#' with 'e' specifier.
  double x = 12.4579;
  char buff[S21_MAX] = "";
  char buff2[S21_MAX] = "";
  sprintf(buff, "TEST21 %+-#e", x);
  s21_sprintf(buff2, "TEST21 %+-#e", x);
  ck_assert_str_eq(buff, buff2);
}
END_TEST

START_TEST(sprintf_spec_exponent22) {
  // Test zero padding with 'e' specifier.
  double x = 12.4579;
  char buff[S21_MAX] = "";
  char buff2[S21_MAX] = "";
  sprintf(buff, "TEST22 %0e", x);
  s21_sprintf(buff2, "TEST22 %0e", x);
  ck_assert_str_eq(buff, buff2);
}
END_TEST

START_TEST(sprintf_spec_exponent23) {
  // Test left-justified with space-prefixed positive number 'e' specifier.
  double x = 12.4579;
  char buff[S21_MAX] = "";
  char buff2[S21_MAX] = "";
  sprintf(buff, "TEST23 %- e", x);
  s21_sprintf(buff2, "TEST23 %- e", x);
  ck_assert_str_eq(buff, buff2);
}
END_TEST

START_TEST(sprintf_spec_exponent24) {
  // Test combination of plus and zero flags with 'e' specifier.
  double x = 12.4579;
  char buff[S21_MAX] = "";
  char buff2[S21_MAX] = "";
  sprintf(buff, "TEST24 %+0e", x);
  s21_sprintf(buff2, "TEST24 %+0e", x);
  ck_assert_str_eq(buff, buff2);
}
END_TEST

START_TEST(sprintf_spec_exponent25) {
  // Test sign-prefixed with 'e' specifier.
  double x = 12.4579;
  char buff[S21_MAX] = "";
  char buff2[S21_MAX] = "";
  sprintf(buff, "TEST25 %+e", x);
  s21_sprintf(buff2, "TEST25 %+e", x);
  ck_assert_str_eq(buff, buff2);
}
END_TEST

START_TEST(sprintf_spec_exponent26) {
  // Test combination of flags: plus, minus, '#', and width with 'e' specifier.
  double x = 12.4579;
  char buff[S21_MAX] = "";
  char buff2[S21_MAX] = "";
  sprintf(buff, "TEST26 %+-#12e", x);
  s21_sprintf(buff2, "TEST26 %+-#12e", x);
  ck_assert_str_eq(buff, buff2);
}
END_TEST

START_TEST(sprintf_spec_exponent27) {
  // Test combination of zero flag, width, and precision with 'e' specifier.
  double x = 12.4579;
  char buff[S21_MAX] = "";
  char buff2[S21_MAX] = "";
  sprintf(buff, "TEST27 %03.11e", x);
  s21_sprintf(buff2, "TEST27 %03.11e", x);
  ck_assert_str_eq(buff, buff2);
}
END_TEST

START_TEST(sprintf_spec_exponent28) {
  // Test combination of plus, minus flags and precision with 'e' specifier.
  double x = 12.4579;
  char buff[S21_MAX] = "";
  char buff2[S21_MAX] = "";
  sprintf(buff, "TEST28 %+-.2e", x);
  s21_sprintf(buff2, "TEST28 %+-.2e", x);
  ck_assert_str_eq(buff, buff2);
}
END_TEST

START_TEST(sprintf_spec_exponent29) {
  // Test combination of plus flag, zero flag, width, and precision with 'e'
  // specifier.
  double x = 12.4579;
  char buff[S21_MAX] = "";
  char buff2[S21_MAX] = "";
  sprintf(buff, "TEST29 %+04.2e", x);
  s21_sprintf(buff2, "TEST29 %+04.2e", x);
  ck_assert_str_eq(buff, buff2);
}
END_TEST

START_TEST(sprintf_spec_exponent30) {
  // Test combination of plus flag and precision with 'e' specifier.
  double x30 = 12.4579;
  char buff30[S21_MAX] = "";
  char buff30_2[S21_MAX] = "";
  sprintf(buff30, "TEST30 %+.e", x30);
  s21_sprintf(buff30_2, "TEST30 %+.e", x30);
  ck_assert_str_eq(buff30, buff30_2);
}
END_TEST

START_TEST(sprintf_spec_exponent31) {
  // Check flags together with specificators and length - e for format %+-#12Le
  long double x1 = 12.4579;
  char buff1[S21_MAX] = "";
  char buff1_2[S21_MAX] = "";
  sprintf(buff1, "TEST1 %+-#12Le", x1);
  s21_sprintf(buff1_2, "TEST1 %+-#12Le", x1);
  ck_assert_str_eq(buff1, buff1_2);
}
END_TEST

START_TEST(sprintf_spec_exponent32) {
  // Check flags together with specificators and length - e for format %03.11Le
  long double x2 = 12.4579;
  char buff2[S21_MAX] = "";
  char buff2_2[S21_MAX] = "";
  sprintf(buff2, "TEST2 %03.11Le", x2);
  s21_sprintf(buff2_2, "TEST2 %03.11Le", x2);
  ck_assert_str_eq(buff2, buff2_2);
}
END_TEST

START_TEST(sprintf_spec_exponent33) {
  // Check flags together with specificators and length - e for format %+-.2Le
  long double x3 = 12.4579;
  char buff3[S21_MAX] = "";
  char buff3_2[S21_MAX] = "";
  sprintf(buff3, "TEST3 %+-.2Le", x3);
  s21_sprintf(buff3_2, "TEST3 %+-.2Le", x3);
  ck_assert_str_eq(buff3, buff3_2);
}
END_TEST

START_TEST(sprintf_spec_exponent34) {
  // Check flags together with specificators and length - e for format %+04.2Le
  long double x4 = 12.4579;
  char buff4[S21_MAX] = "";
  char buff4_2[S21_MAX] = "";
  sprintf(buff4, "TEST4 %+04.2Le", x4);
  s21_sprintf(buff4_2, "TEST4 %+04.2Le", x4);
  ck_assert_str_eq(buff4, buff4_2);
}
END_TEST

START_TEST(sprintf_spec_exponent35) {
  // Check flags together with specificators and length - e for format % .Le
  long double x5 = 12.4579;
  char buff5[S21_MAX] = "";
  char buff5_2[S21_MAX] = "";
  sprintf(buff5, "TEST5 % .Le", x5);
  s21_sprintf(buff5_2, "TEST5 % .Le", x5);
  ck_assert_str_eq(buff5, buff5_2);
}
END_TEST

START_TEST(sprintf_spec_exponent36) {
  // Check case with basic %E
  double x = 12.4579;
  char buff[S21_MAX] = "";
  char buff2[S21_MAX] = "";
  sprintf(buff, "TEST1 %E", x);
  s21_sprintf(buff2, "TEST1 %E", x);
  ck_assert_str_eq(buff, buff2);
}
END_TEST

START_TEST(sprintf_spec_exponent37) {
  // Check case with flag %0E
  double x = 12.4579;
  char buff[S21_MAX] = "";
  char buff2[S21_MAX] = "";
  sprintf(buff, "TEST2 %0E", x);
  s21_sprintf(buff2, "TEST2 %0E", x);
  ck_assert_str_eq(buff, buff2);
}
END_TEST

START_TEST(sprintf_spec_exponent38) {
  // Check case with flag % E
  double x = 12.4579;
  char buff[S21_MAX] = "";
  char buff2[S21_MAX] = "";
  sprintf(buff, "TEST3 % E", x);
  s21_sprintf(buff2, "TEST3 % E", x);
  ck_assert_str_eq(buff, buff2);
}
END_TEST

START_TEST(sprintf_spec_exponent39) {
  // Check case with flag %-E
  double x = 12.4579;
  char buff[S21_MAX] = "";
  char buff2[S21_MAX] = "";
  sprintf(buff, "TEST4 %-E", x);
  s21_sprintf(buff2, "TEST4 %-E", x);
  ck_assert_str_eq(buff, buff2);
}
END_TEST

START_TEST(sprintf_spec_exponent40) {
  // Check case with flag %+E
  double x = 12.4579;
  char buff[S21_MAX] = "";
  char buff2[S21_MAX] = "";
  sprintf(buff, "TEST5 %+E", x);
  s21_sprintf(buff2, "TEST5 %+E", x);
  ck_assert_str_eq(buff, buff2);
}
END_TEST

START_TEST(sprintf_spec_exponent41) {
  // Check case with specificator1 %.E
  double x = 12.4579;
  char buff[S21_MAX] = "";
  char buff2[S21_MAX] = "";
  sprintf(buff, "TEST1 %.E", x);
  s21_sprintf(buff2, "TEST1 %.E", x);
  ck_assert_str_eq(buff, buff2);
}
END_TEST

START_TEST(sprintf_spec_exponent42) {
  // Check case with specificator1 %5.E
  double x = 12.4579;
  char buff[S21_MAX] = "";
  char buff2[S21_MAX] = "";
  sprintf(buff, "TEST2 %5.E", x);
  s21_sprintf(buff2, "TEST2 %5.E", x);
  ck_assert_str_eq(buff, buff2);
}
END_TEST

START_TEST(sprintf_spec_exponent43) {
  // Check case with specificator1 %5.3E
  double x = 12.4579;
  char buff[S21_MAX] = "";
  char buff2[S21_MAX] = "";
  sprintf(buff, "TEST3 %5.3E", x);
  s21_sprintf(buff2, "TEST3 %5.3E", x);
  ck_assert_str_eq(buff, buff2);
}
END_TEST

START_TEST(sprintf_spec_exponent44) {
  // Check case with specificator1 %.5E
  double x = 12.4579;
  char buff[S21_MAX] = "";
  char buff2[S21_MAX] = "";
  sprintf(buff, "TEST4 %.5E", x);
  s21_sprintf(buff2, "TEST4 %.5E", x);
  ck_assert_str_eq(buff, buff2);
}
END_TEST

START_TEST(sprintf_spec_exponent45) {
  // Check case with specificator1 %5.5E
  double x = 12.4579;
  char buff[S21_MAX] = "";
  char buff2[S21_MAX] = "";
  sprintf(buff, "TEST5 %5.5E", x);
  s21_sprintf(buff2, "TEST5 %5.5E", x);
  ck_assert_str_eq(buff, buff2);
}
END_TEST

START_TEST(sprintf_spec_exponent46) {
  // Check case with specificator %.E and big number
  double x = 122332483472728.4579;
  char buff[S21_MAX] = "";
  char buff2[S21_MAX] = "";
  sprintf(buff, "TEST1 %.E", x);
  s21_sprintf(buff2, "TEST1 %.E", x);
  ck_assert_str_eq(buff, buff2);
}
END_TEST

START_TEST(sprintf_spec_exponent47) {
  // Check case with specificator %5.E and big number
  double x = 122332483472728.4579;
  char buff[S21_MAX] = "";
  char buff2[S21_MAX] = "";
  sprintf(buff, "TEST2 %5.E", x);
  s21_sprintf(buff2, "TEST2 %5.E", x);
  ck_assert_str_eq(buff, buff2);
}
END_TEST

START_TEST(sprintf_spec_exponent48) {
  // Check case with specificator %5E and big number
  double x = 122332483472728.4579;
  char buff[S21_MAX] = "";
  char buff2[S21_MAX] = "";
  sprintf(buff, "TEST3 %5E", x);
  s21_sprintf(buff2, "TEST3 %5E", x);
  ck_assert_str_eq(buff, buff2);
}
END_TEST

START_TEST(sprintf_spec_exponent49) {
  // Check case with specificator %.5E and big number
  double x = 122332483472728.4579;
  char buff[S21_MAX] = "";
  char buff2[S21_MAX] = "";
  sprintf(buff, "TEST4 %.5E", x);
  s21_sprintf(buff2, "TEST4 %.5E", x);
  ck_assert_str_eq(buff, buff2);
}
END_TEST

START_TEST(sprintf_spec_exponent50) {
  // Check case with specificator %5.5E and big number
  double x = 122332483472728.4579;
  char buff[S21_MAX] = "";
  char buff2[S21_MAX] = "";
  sprintf(buff, "TEST5 %5.5E", x);
  s21_sprintf(buff2, "TEST5 %5.5E", x);
  ck_assert_str_eq(buff, buff2);
}
END_TEST

START_TEST(sprintf_spec_exponent51) {
  // Check length case with specificator %LE
  long double x = 12.4579;
  char buff[S21_MAX] = "";
  char buff2[S21_MAX] = "";
  sprintf(buff, "TEST1 %LE", x);
  s21_sprintf(buff2, "TEST1 %LE", x);
  ck_assert_str_eq(buff, buff2);
}
END_TEST

START_TEST(sprintf_spec_exponent52) {
  // Check length case with specificator %5.LE
  long double x = 12.4579;
  char buff[S21_MAX] = "";
  char buff2[S21_MAX] = "";
  sprintf(buff, "TEST2 %5.LE", x);
  s21_sprintf(buff2, "TEST2 %5.LE", x);
  ck_assert_str_eq(buff, buff2);
}
END_TEST

START_TEST(sprintf_spec_exponent53) {
  // Check length case with specificator %5LE
  long double x = 12.4579;
  char buff[S21_MAX] = "";
  char buff2[S21_MAX] = "";
  sprintf(buff, "TEST3 %5LE", x);
  s21_sprintf(buff2, "TEST3 %5LE", x);
  ck_assert_str_eq(buff, buff2);
}
END_TEST

START_TEST(sprintf_spec_exponent54) {
  // Check length case with specificator %.5LE
  long double x = 12.4579;
  char buff[S21_MAX] = "";
  char buff2[S21_MAX] = "";
  sprintf(buff, "TEST4 %.5LE", x);
  s21_sprintf(buff2, "TEST4 %.5LE", x);
  ck_assert_str_eq(buff, buff2);
}
END_TEST

START_TEST(sprintf_spec_exponent55) {
  // Check length case with specificator %5.5LE
  long double x = 12.4579;
  char buff[S21_MAX] = "";
  char buff2[S21_MAX] = "";
  sprintf(buff, "TEST5 %5.5LE", x);
  s21_sprintf(buff2, "TEST5 %5.5LE", x);
  ck_assert_str_eq(buff, buff2);
}
END_TEST

START_TEST(sprintf_spec_exponent56) {
  // Check flags with '+' and '#' and 'E' specifier.
  double x = 12.4579;
  char buff[S21_MAX] = "";
  char buff2[S21_MAX] = "";
  sprintf(buff, "TEST36a %+-#E", x);
  s21_sprintf(buff2, "TEST36a %+-#E", x);
  ck_assert_str_eq(buff, buff2);
}
END_TEST

START_TEST(sprintf_spec_exponent57) {
  // Check left-justified with 'E' specifier.
  double x = 12.4579;
  char buff[S21_MAX] = "";
  char buff2[S21_MAX] = "";
  sprintf(buff, "TEST36b %-E", x);
  s21_sprintf(buff2, "TEST36b %-E", x);
  ck_assert_str_eq(buff, buff2);
}
END_TEST

START_TEST(sprintf_spec_exponent58) {
  // Check space-prefixed with 'E' specifier.
  double x = 12.4579;
  char buff[S21_MAX] = "";
  char buff2[S21_MAX] = "";
  sprintf(buff, "TEST36c %- E", x);
  s21_sprintf(buff2, "TEST36c %- E", x);
  ck_assert_str_eq(buff, buff2);
}
END_TEST

START_TEST(sprintf_spec_exponent59) {
  // Check sign-prefixed with zero-padding and 'E' specifier.
  double x = 12.4579;
  char buff[S21_MAX] = "";
  char buff2[S21_MAX] = "";
  sprintf(buff, "TEST36d %+0E", x);
  s21_sprintf(buff2, "TEST36d %+0E", x);
  ck_assert_str_eq(buff, buff2);
}
END_TEST

START_TEST(sprintf_spec_exponent60) {
  // Check sign-prefixed with 'E' specifier.
  double x = 12.4579;
  char buff[S21_MAX] = "";
  char buff2[S21_MAX] = "";
  sprintf(buff, "TEST36e %+E", x);
  s21_sprintf(buff2, "TEST36e %+E", x);
  ck_assert_str_eq(buff, buff2);
}
END_TEST

START_TEST(sprintf_spec_exponent61) {
  // Test combination of flags: plus, minus, '#', and width with 'LE' specifier
  // for long double.
  long double x = 12.4579;
  char buff[S21_MAX] = "";
  char buff2[S21_MAX] = "";
  sprintf(buff, "TEST31 %+-#12LE", x);
  s21_sprintf(buff2, "TEST31 %+-#12LE", x);
  ck_assert_str_eq(buff, buff2);
}
END_TEST

START_TEST(sprintf_spec_exponent62) {
  // Test combination of minus flag, width, and precision with 'LE' specifier
  // for long double.
  long double x = 12.4579;
  char buff[S21_MAX] = "";
  char buff2[S21_MAX] = "";
  sprintf(buff, "TEST32 %-3.11LE", x);
  s21_sprintf(buff2, "TEST32 %-3.11LE", x);
  ck_assert_str_eq(buff, buff2);
}
END_TEST

START_TEST(sprintf_spec_exponent63) {
  // Test combination of plus, minus flags and precision with 'LE' specifier for
  // long double.
  long double x = 12.4579;
  char buff[S21_MAX] = "";
  char buff2[S21_MAX] = "";
  sprintf(buff, "TEST33 %+-.2LE", x);
  s21_sprintf(buff2, "TEST33 %+-.2LE", x);
  ck_assert_str_eq(buff, buff2);
}
END_TEST

START_TEST(sprintf_spec_exponent64) {
  // Test combination of plus flag, zero flag, width, and precision with 'LE'
  // specifier for long double.
  long double x = 12.4579;
  char buff[S21_MAX] = "";
  char buff2[S21_MAX] = "";
  sprintf(buff, "TEST34 %+04.2LE", x);
  s21_sprintf(buff2, "TEST34 %+04.2LE", x);
  ck_assert_str_eq(buff, buff2);
}
END_TEST

START_TEST(sprintf_spec_exponent65) {
  // Test combination of space flag and precision with 'LE' specifier for long
  // double.
  long double x = 12.4579;
  char buff[S21_MAX] = "";
  char buff2[S21_MAX] = "";
  sprintf(buff, "TEST35 % .LE", x);
  s21_sprintf(buff2, "TEST35 % .LE", x);
  ck_assert_str_eq(buff, buff2);
}
END_TEST

START_TEST(sprintf_spec_exponent66) {
  // Check negative number with 'e' specifier.
  double x = -12.4579;
  char buff[S21_MAX] = "";
  char buff2[S21_MAX] = "";
  sprintf(buff, "TEST46a %e", x);
  s21_sprintf(buff2, "TEST46a %e", x);
  ck_assert_str_eq(buff, buff2);
}
END_TEST

START_TEST(sprintf_spec_exponent67) {
  // Check negative number with 'E' specifier.
  double x = -12.4579;
  char buff[S21_MAX] = "";
  char buff2[S21_MAX] = "";
  sprintf(buff, "TEST46b %E", x);
  s21_sprintf(buff2, "TEST46b %E", x);
  ck_assert_str_eq(buff, buff2);
}
END_TEST

START_TEST(sprintf_spec_exponent68) {
  // Check negative number with sign-prefixed 'e' specifier.
  double x = -12.4579;
  char buff[S21_MAX] = "";
  char buff2[S21_MAX] = "";
  sprintf(buff, "TEST46c %+e", x);
  s21_sprintf(buff2, "TEST46c %+e", x);
  ck_assert_str_eq(buff, buff2);
}
END_TEST

START_TEST(sprintf_spec_exponent69) {
  // Check negative number with sign-prefixed 'E' specifier.
  double x = -12.4579;
  char buff[S21_MAX] = "";
  char buff2[S21_MAX] = "";
  sprintf(buff, "TEST46d %+E", x);
  s21_sprintf(buff2, "TEST46d %+E", x);
  ck_assert_str_eq(buff, buff2);
}
END_TEST

START_TEST(sprintf_spec_exponent70) {
  // Check number less than one with 'e' specifier.
  double x = 0.004579;
  char buff[S21_MAX] = "";
  char buff2[S21_MAX] = "";
  sprintf(buff, "TEST44 %e", x);
  s21_sprintf(buff2, "TEST44 %e", x);
  ck_assert_str_eq(buff, buff2);
}
END_TEST

START_TEST(sprintf_spec_exponent71) {
  // Check number less than one with 'E' specifier.
  double x = 0.004579;
  char buff[S21_MAX] = "";
  char buff2[S21_MAX] = "";
  sprintf(buff, "TEST45 %E", x);
  s21_sprintf(buff2, "TEST45 %E", x);
  ck_assert_str_eq(buff, buff2);
}
END_TEST

START_TEST(sprintf_spec_exponent72) {
  // Check number less than one with 'e' specifier, width and precision.
  double x = 0.004579;
  char buff[S21_MAX] = "";
  char buff2[S21_MAX] = "";
  sprintf(buff, "TEST46 %3.5e", x);
  s21_sprintf(buff2, "TEST46 %3.5e", x);
  ck_assert_str_eq(buff, buff2);
}
END_TEST

START_TEST(sprintf_spec_exponent73) {
  // Check number less than one with 'E' specifier, width and precision.
  double x = 0.004579;
  char buff[S21_MAX] = "";
  char buff2[S21_MAX] = "";
  sprintf(buff, "TEST47 %3.5E", x);
  s21_sprintf(buff2, "TEST47 %3.5E", x);
  ck_assert_str_eq(buff, buff2);
}
END_TEST

START_TEST(sprintf_spec_exponent74) {
  // Check the case of dynamic precision for double with 'e' specificator
  int s = 3;
  double x = 12.4579;
  char buff[S21_MAX] = "";
  char buff2[S21_MAX] = "";
  sprintf(buff, "TEST1 %*.e", s, x);
  s21_sprintf(buff2, "TEST1 %*.e", s, x);
  ck_assert_str_eq(buff, buff2);
}
END_TEST

START_TEST(sprintf_spec_exponent75) {
  // Check dynamic precision with set width for double with 'e' specificator
  int s = 3;
  double x = 12.4579;
  char buff[S21_MAX] = "";
  char buff2[S21_MAX] = "";
  sprintf(buff, "TEST2 %5.*e", s, x);
  s21_sprintf(buff2, "TEST2 %5.*e", s, x);
  ck_assert_str_eq(buff, buff2);
}
END_TEST

START_TEST(sprintf_spec_exponent76) {
  // Check dynamic width and precision for double with 'e' specificator
  int s = 3;
  double x = 12.4579;
  char buff[S21_MAX] = "";
  char buff2[S21_MAX] = "";
  sprintf(buff, "TEST3 %*.*e", s, s, x);
  s21_sprintf(buff2, "TEST3 %*.*e", s, s, x);
  ck_assert_str_eq(buff, buff2);
}
END_TEST

START_TEST(sprintf_spec_exponent77) {
  // Tests the behavior of s21_sprintf for formatting a long double in exponent
  // notation using width
  int s = 3;
  long double y = 1245.32435;
  char buff[S21_MAX] = "";
  char buff2[S21_MAX] = "";
  sprintf(buff, "TEST4 %*Le", s, y);
  s21_sprintf(buff2, "TEST4 %*Le", s, y);
  ck_assert_str_eq(buff, buff2);
}
END_TEST

START_TEST(sprintf_spec_exponent78) {
  // Tests s21_sprintf for formatting a long double using both width and
  // precision in exponent notation
  int s = 3;
  long double y = 1245.32435;
  char buff[S21_MAX] = "";
  char buff2[S21_MAX] = "";
  sprintf(buff, "TEST5 %*.*Le", s, s, y);
  s21_sprintf(buff2, "TEST5 %*.*Le", s, s, y);
  ck_assert_str_eq(buff, buff2);
}
END_TEST

START_TEST(sprintf_spec_float1) {
  // Check case with flag %g
  double x = 12.4579;
  char buff[S21_MAX] = "";
  char buff2[S21_MAX] = "";
  sprintf(buff, "TEST1 %g", x);
  s21_sprintf(buff2, "TEST1 %g", x);
  ck_assert_str_eq(buff, buff2);
}
END_TEST

START_TEST(sprintf_spec_float2) {
  // Check case with flag %0g
  double x = 12.4579;
  char buff[S21_MAX] = "";
  char buff2[S21_MAX] = "";
  sprintf(buff, "TEST2 %0g", x);
  s21_sprintf(buff2, "TEST2 %0g", x);
  ck_assert_str_eq(buff, buff2);
}
END_TEST

START_TEST(sprintf_spec_float3) {
  // Check case with flag % g
  double x = 12.4579;
  char buff[S21_MAX] = "";
  char buff2[S21_MAX] = "";
  sprintf(buff, "TEST3 % g", x);
  s21_sprintf(buff2, "TEST3 % g", x);
  ck_assert_str_eq(buff, buff2);
}
END_TEST

START_TEST(sprintf_spec_float4) {
  // Check case with flag %-g
  double x = 12.4579;
  char buff[S21_MAX] = "";
  char buff2[S21_MAX] = "";
  sprintf(buff, "TEST4 %-g", x);
  s21_sprintf(buff2, "TEST4 %-g", x);
  ck_assert_str_eq(buff, buff2);
}
END_TEST

START_TEST(sprintf_spec_float5) {
  // Check case with flag %+g
  double x = 12.4579;
  char buff[S21_MAX] = "";
  char buff2[S21_MAX] = "";
  sprintf(buff, "TEST5 %+g", x);
  s21_sprintf(buff2, "TEST5 %+g", x);
  ck_assert_str_eq(buff, buff2);
}
END_TEST

START_TEST(sprintf_spec_float6) {
  // Check case with specificator %.g
  double x = 12.4579;
  char buff[S21_MAX] = "";
  char buff2[S21_MAX] = "";
  sprintf(buff, "TEST1 %.g", x);
  s21_sprintf(buff2, "TEST1 %.g", x);
  ck_assert_str_eq(buff, buff2);
}
END_TEST

START_TEST(sprintf_spec_float7) {
  // Check case with specificator %5.g
  double x = 12.4579;
  char buff[S21_MAX] = "";
  char buff2[S21_MAX] = "";
  sprintf(buff, "TEST2 %5.g", x);
  s21_sprintf(buff2, "TEST2 %5.g", x);
  ck_assert_str_eq(buff, buff2);
}
END_TEST

START_TEST(sprintf_spec_float8) {
  // Check case with specificator %5g
  double x = 12.4579;
  char buff[S21_MAX] = "";
  char buff2[S21_MAX] = "";
  sprintf(buff, "TEST3 %5g", x);
  s21_sprintf(buff2, "TEST3 %5g", x);
  ck_assert_str_eq(buff, buff2);
}
END_TEST

START_TEST(sprintf_spec_float9) {
  // Check case with specificator %.5g
  double x = 12.4579;
  char buff[S21_MAX] = "";
  char buff2[S21_MAX] = "";
  sprintf(buff, "TEST4 %.5g", x);
  s21_sprintf(buff2, "TEST4 %.5g", x);
  ck_assert_str_eq(buff, buff2);
}
END_TEST

START_TEST(sprintf_spec_float10) {
  // Check case with specificator %5.5g
  double x = 12.4579;
  char buff[S21_MAX] = "";
  char buff2[S21_MAX] = "";
  sprintf(buff, "TEST5 %5.5g", x);
  s21_sprintf(buff2, "TEST5 %5.5g", x);
  ck_assert_str_eq(buff, buff2);
}
END_TEST

START_TEST(sprintf_spec_float11) {
  // Check case with specificator %.g and big number
  double x = -122332483472728.4579;
  char buff[S21_MAX] = "";
  char buff2[S21_MAX] = "";
  sprintf(buff, "TEST1 %.g", x);
  s21_sprintf(buff2, "TEST1 %.g", x);
  ck_assert_str_eq(buff, buff2);
}
END_TEST

START_TEST(sprintf_spec_float12) {
  // Check case with specificator %5.g and big number
  double x = -122332483472728.4579;
  char buff[S21_MAX] = "";
  char buff2[S21_MAX] = "";
  sprintf(buff, "TEST2 %5.g", x);
  s21_sprintf(buff2, "TEST2 %5.g", x);
  ck_assert_str_eq(buff, buff2);
}
END_TEST

START_TEST(sprintf_spec_float13) {
  // Check case with specificator %5g and big number
  double x = -122332483472728.4579;
  char buff[S21_MAX] = "";
  char buff2[S21_MAX] = "";
  sprintf(buff, "TEST3 %5g", x);
  s21_sprintf(buff2, "TEST3 %5g", x);
  ck_assert_str_eq(buff, buff2);
}
END_TEST

START_TEST(sprintf_spec_float14) {
  // Check case with specificator %.5g and big number
  double x = -122332483472728.4579;
  char buff[S21_MAX] = "";
  char buff2[S21_MAX] = "";
  sprintf(buff, "TEST4 %.5g", x);
  s21_sprintf(buff2, "TEST4 %.5g", x);
  ck_assert_str_eq(buff, buff2);
}
END_TEST

START_TEST(sprintf_spec_float15) {
  // Check case with specificator %5.5g and big number
  double x = -122332483472728.4579;
  char buff[S21_MAX] = "";
  char buff2[S21_MAX] = "";
  sprintf(buff, "TEST5 %5.5g", x);
  s21_sprintf(buff2, "TEST5 %5.5g", x);
  ck_assert_str_eq(buff, buff2);
}
END_TEST

START_TEST(sprintf_spec_float16) {
  // Check length specificator %Lg
  long double x = -12.4579;
  char buff[S21_MAX] = "";
  char buff2[S21_MAX] = "";
  sprintf(buff, "TEST1 %Lg", x);
  s21_sprintf(buff2, "TEST1 %Lg", x);
  ck_assert_str_eq(buff, buff2);
}
END_TEST

START_TEST(sprintf_spec_float17) {
  // Check length specificator %5.Lg
  long double x = -12.4579;
  char buff[S21_MAX] = "";
  char buff2[S21_MAX] = "";
  sprintf(buff, "TEST2 %5.Lg", x);
  s21_sprintf(buff2, "TEST2 %5.Lg", x);
  ck_assert_str_eq(buff, buff2);
}
END_TEST

START_TEST(sprintf_spec_float18) {
  // Check length specificator %5Lg
  long double x = -12.4579;
  char buff[S21_MAX] = "";
  char buff2[S21_MAX] = "";
  sprintf(buff, "TEST3 %5Lg", x);
  s21_sprintf(buff2, "TEST3 %5Lg", x);
  ck_assert_str_eq(buff, buff2);
}
END_TEST

START_TEST(sprintf_spec_float19) {
  // Check length specificator %.5Lg
  long double x = -12.4579;
  char buff[S21_MAX] = "";
  char buff2[S21_MAX] = "";
  sprintf(buff, "TEST4 %.5Lg", x);
  s21_sprintf(buff2, "TEST4 %.5Lg", x);
  ck_assert_str_eq(buff, buff2);
}
END_TEST

START_TEST(sprintf_spec_float20) {
  // Check length specificator %5.5Lg
  long double x = -12.4579;
  char buff[S21_MAX] = "";
  char buff2[S21_MAX] = "";
  sprintf(buff, "TEST5 %5.5Lg", x);
  s21_sprintf(buff2, "TEST5 %5.5Lg", x);
  ck_assert_str_eq(buff, buff2);
}
END_TEST

START_TEST(sprintf_spec_float21) {
  // Check flags %+-#g together
  double x = 12.4579;
  char buff[S21_MAX] = "";
  char buff2[S21_MAX] = "";
  sprintf(buff, "TEST1 %+-#g", x);
  s21_sprintf(buff2, "TEST1 %+-#g", x);
  ck_assert_str_eq(buff, buff2);
}
END_TEST

START_TEST(sprintf_spec_float22) {
  // Check flag %-
  double x = 12.4579;
  char buff[S21_MAX] = "";
  char buff2[S21_MAX] = "";
  sprintf(buff, "TEST2 %-g", x);
  s21_sprintf(buff2, "TEST2 %-g", x);
  ck_assert_str_eq(buff, buff2);
}
END_TEST

START_TEST(sprintf_spec_float23) {
  // Check flags %+-
  double x = 12.4579;
  char buff[S21_MAX] = "";
  char buff2[S21_MAX] = "";
  sprintf(buff, "TEST3 %+-g", x);
  s21_sprintf(buff2, "TEST3 %+-g", x);
  ck_assert_str_eq(buff, buff2);
}
END_TEST

START_TEST(sprintf_spec_float24) {
  // Check flags %+0
  double x = 12.4579;
  char buff[S21_MAX] = "";
  char buff2[S21_MAX] = "";
  sprintf(buff, "TEST4 %+0g", x);
  s21_sprintf(buff2, "TEST4 %+0g", x);
  ck_assert_str_eq(buff, buff2);
}
END_TEST

START_TEST(sprintf_spec_float25) {
  // Check flag combination %- and space
  double x = 12.4579;
  char buff[S21_MAX] = "";
  char buff2[S21_MAX] = "";
  sprintf(buff, "TEST5 %- g", x);
  s21_sprintf(buff2, "TEST5 %- g", x);
  ck_assert_str_eq(buff, buff2);
}
END_TEST

START_TEST(sprintf_spec_float26) {
  // Check flags %+-# together with width 12 - g
  double x = 12.4579;
  char buff[S21_MAX] = "";
  char buff2[S21_MAX] = "";
  sprintf(buff, "TEST1 %+-#12g", x);
  s21_sprintf(buff2, "TEST1 %+-#12g", x);
  ck_assert_str_eq(buff, buff2);
}
END_TEST

START_TEST(sprintf_spec_float27) {
  // Check flags %0 and precision .11 - g
  double x = 12.4579;
  char buff[S21_MAX] = "";
  char buff2[S21_MAX] = "";
  sprintf(buff, "TEST2 %03.11g", x);
  s21_sprintf(buff2, "TEST2 %03.11g", x);
  ck_assert_str_eq(buff, buff2);
}
END_TEST

START_TEST(sprintf_spec_float28) {
  // Check flags %+-. and precision .2 - g
  double x = 12.4579;
  char buff[S21_MAX] = "";
  char buff2[S21_MAX] = "";
  sprintf(buff, "TEST3 %+-.2g", x);
  s21_sprintf(buff2, "TEST3 %+-.2g", x);
  ck_assert_str_eq(buff, buff2);
}
END_TEST

START_TEST(sprintf_spec_float29) {
  // Check flags %+0, width 4 and precision .2 - g
  double x = 12.4579;
  char buff[S21_MAX] = "";
  char buff2[S21_MAX] = "";
  sprintf(buff, "TEST4 %+04.2g", x);
  s21_sprintf(buff2, "TEST4 %+04.2g", x);
  ck_assert_str_eq(buff, buff2);
}
END_TEST

START_TEST(sprintf_spec_float30) {
  // Check flag combination %- with space and precision . - g
  double x = 12.4579;
  char buff[S21_MAX] = "";
  char buff2[S21_MAX] = "";
  sprintf(buff, "TEST5 %- .g", x);
  s21_sprintf(buff2, "TEST5 %- .g", x);
  ck_assert_str_eq(buff, buff2);
}
END_TEST

START_TEST(sprintf_spec_float31) {
  // Check '*' for width with specificator - g
  int s = 3;
  double x = 12.4579;
  char buff[S21_MAX] = "";
  char buff2[S21_MAX] = "";
  sprintf(buff, "TEST1 %*.g", s, x);
  s21_sprintf(buff2, "TEST1 %*.g", s, x);
  ck_assert_str_eq(buff, buff2);
}
END_TEST

START_TEST(sprintf_spec_float32) {
  // Check '*' for precision with width 5 and specificator - g
  int s = 3;
  double x = 12.4579;
  char buff[S21_MAX] = "";
  char buff2[S21_MAX] = "";
  sprintf(buff, "TEST2 %5.*g", s, x);
  s21_sprintf(buff2, "TEST2 %5.*g", s, x);
  ck_assert_str_eq(buff, buff2);
}
END_TEST

START_TEST(sprintf_spec_float33) {
  // Check '*' for width and precision with specificator - g
  int s = 3;
  double x = 12.4579;
  char buff[S21_MAX] = "";
  char buff2[S21_MAX] = "";
  sprintf(buff, "TEST3 %*.*g", s, s, x);
  s21_sprintf(buff2, "TEST3 %*.*g", s, s, x);
  ck_assert_str_eq(buff, buff2);
}
END_TEST

START_TEST(sprintf_spec_float34) {
  // Check '*' for width with long double specificator - g
  int s = 3;
  long double y = 1245.32435;
  char buff[S21_MAX] = "";
  char buff2[S21_MAX] = "";
  sprintf(buff, "TEST4 %*Lg", s, y);
  s21_sprintf(buff2, "TEST4 %*Lg", s, y);
  ck_assert_str_eq(buff, buff2);
}
END_TEST

START_TEST(sprintf_spec_float35) {
  // Check '*' for width and precision with long double specificator - g
  int s = 3;
  long double y = 1245.32435;
  char buff[S21_MAX] = "";
  char buff2[S21_MAX] = "";
  sprintf(buff, "TEST5 %*.*Lg", s, s, y);
  s21_sprintf(buff2, "TEST5 %*.*Lg", s, s, y);
  ck_assert_str_eq(buff, buff2);
}
END_TEST

START_TEST(sprintf_spec_float36) {
  // Check flags combination %+-#12Lg - g
  long double x = 12.4579;
  char buff[S21_MAX] = "";
  char buff2[S21_MAX] = "";
  sprintf(buff, "TEST1 %+-#12Lg", x);
  s21_sprintf(buff2, "TEST1 %+-#12Lg", x);
  ck_assert_str_eq(buff, buff2);
}
END_TEST

START_TEST(sprintf_spec_float37) {
  // Check flags combination %03.11Lg - g
  long double x = 12.4579;
  char buff[S21_MAX] = "";
  char buff2[S21_MAX] = "";
  sprintf(buff, "TEST2 %03.11Lg", x);
  s21_sprintf(buff2, "TEST2 %03.11Lg", x);
  ck_assert_str_eq(buff, buff2);
}
END_TEST

START_TEST(sprintf_spec_float38) {
  // Check flags combination %+-.2Lg - g
  long double x = 12.4579;
  char buff[S21_MAX] = "";
  char buff2[S21_MAX] = "";
  sprintf(buff, "TEST3 %+-.2Lg", x);
  s21_sprintf(buff2, "TEST3 %+-.2Lg", x);
  ck_assert_str_eq(buff, buff2);
}
END_TEST

START_TEST(sprintf_spec_float39) {
  // Check flags combination %+04.2Lg - g
  long double x = 12.4579;
  char buff[S21_MAX] = "";
  char buff2[S21_MAX] = "";
  sprintf(buff, "TEST4 %+04.2Lg", x);
  s21_sprintf(buff2, "TEST4 %+04.2Lg", x);
  ck_assert_str_eq(buff, buff2);
}
END_TEST

START_TEST(sprintf_spec_float40) {
  // Check flags combination %- .Lg - g
  long double x = 12.4579;
  char buff[S21_MAX] = "";
  char buff2[S21_MAX] = "";
  sprintf(buff, "TEST5 %- .Lg", x);
  s21_sprintf(buff2, "TEST5 %- .Lg", x);
  ck_assert_str_eq(buff, buff2);
}
END_TEST

START_TEST(sprintf_spec_float41) {
  // Check case with flag %G
  double x = 12.4579;
  char buff[S21_MAX] = "";
  char buff2[S21_MAX] = "";
  sprintf(buff, "TEST1 %G", x);
  s21_sprintf(buff2, "TEST1 %G", x);
  ck_assert_str_eq(buff, buff2);
}
END_TEST

START_TEST(sprintf_spec_float42) {
  // Check case with flag %0G
  double x = 12.4579;
  char buff[S21_MAX] = "";
  char buff2[S21_MAX] = "";
  sprintf(buff, "TEST2 %0G", x);
  s21_sprintf(buff2, "TEST2 %0G", x);
  ck_assert_str_eq(buff, buff2);
}
END_TEST

START_TEST(sprintf_spec_float43) {
  // Check case with flag % G
  double x = 12.4579;
  char buff[S21_MAX] = "";
  char buff2[S21_MAX] = "";
  sprintf(buff, "TEST3 % G", x);
  s21_sprintf(buff2, "TEST3 % G", x);
  ck_assert_str_eq(buff, buff2);
}
END_TEST

START_TEST(sprintf_spec_float44) {
  // Check case with flag %-G
  double x = 12.4579;
  char buff[S21_MAX] = "";
  char buff2[S21_MAX] = "";
  sprintf(buff, "TEST4 %-G", x);
  s21_sprintf(buff2, "TEST4 %-G", x);
  ck_assert_str_eq(buff, buff2);
}
END_TEST

START_TEST(sprintf_spec_float45) {
  // Check case with flag %+G
  double x = 12.4579;
  char buff[S21_MAX] = "";
  char buff2[S21_MAX] = "";
  sprintf(buff, "TEST5 %+G", x);
  s21_sprintf(buff2, "TEST5 %+G", x);
  ck_assert_str_eq(buff, buff2);
}
END_TEST

START_TEST(sprintf_spec_float46) {
  // Check case with specificator %G
  double x = -12.4579;
  char buff[S21_MAX] = "";
  char buff2[S21_MAX] = "";
  sprintf(buff, "TEST1 %G", x);
  s21_sprintf(buff2, "TEST1 %G", x);
  ck_assert_str_eq(buff, buff2);
}
END_TEST

START_TEST(sprintf_spec_float47) {
  // Check case with specificator %.G
  double x = -12.4579;
  char buff[S21_MAX] = "";
  char buff2[S21_MAX] = "";
  sprintf(buff, "TEST2 %.G", x);
  s21_sprintf(buff2, "TEST2 %.G", x);
  ck_assert_str_eq(buff, buff2);
}
END_TEST

START_TEST(sprintf_spec_float48) {
  // Check case with specificator %5G
  double x = -12.4579;
  char buff[S21_MAX] = "";
  char buff2[S21_MAX] = "";
  sprintf(buff, "TEST3 %5G", x);
  s21_sprintf(buff2, "TEST3 %5G", x);
  ck_assert_str_eq(buff, buff2);
}
END_TEST

START_TEST(sprintf_spec_float49) {
  // Check case with specificator %.5G
  double x = -12.4579;
  char buff[S21_MAX] = "";
  char buff2[S21_MAX] = "";
  sprintf(buff, "TEST4 %.5G", x);
  s21_sprintf(buff2, "TEST4 %.5G", x);
  ck_assert_str_eq(buff, buff2);
}
END_TEST

START_TEST(sprintf_spec_float50) {
  // Check case with specificator %5.5G
  double x = -12.4579;
  char buff[S21_MAX] = "";
  char buff2[S21_MAX] = "";
  sprintf(buff, "TEST5 %5.5G", x);
  s21_sprintf(buff2, "TEST5 %5.5G", x);
  ck_assert_str_eq(buff, buff2);
}
END_TEST

START_TEST(sprintf_spec_float51) {
  // Check case with specificator %G and big number
  double x = 122332483472728.4579;
  char buff[S21_MAX] = "";
  char buff2[S21_MAX] = "";
  sprintf(buff, "TEST1 %G", x);
  s21_sprintf(buff2, "TEST1 %G", x);
  ck_assert_str_eq(buff, buff2);
}
END_TEST

START_TEST(sprintf_spec_float52) {
  // Check case with specificator %.G and big number
  double x = 122332483472728.4579;
  char buff[S21_MAX] = "";
  char buff2[S21_MAX] = "";
  sprintf(buff, "TEST2 %.G", x);
  s21_sprintf(buff2, "TEST2 %.G", x);
  ck_assert_str_eq(buff, buff2);
}
END_TEST

START_TEST(sprintf_spec_float53) {
  // Check case with specificator %5G and big number
  double x = 122332483472728.4579;
  char buff[S21_MAX] = "";
  char buff2[S21_MAX] = "";
  sprintf(buff, "TEST3 %5G", x);
  s21_sprintf(buff2, "TEST3 %5G", x);
  ck_assert_str_eq(buff, buff2);
}
END_TEST

START_TEST(sprintf_spec_float54) {
  // Check case with specificator %.5G and big number
  double x = 122332483472728.4579;
  char buff[S21_MAX] = "";
  char buff2[S21_MAX] = "";
  sprintf(buff, "TEST4 %.5G", x);
  s21_sprintf(buff2, "TEST4 %.5G", x);
  ck_assert_str_eq(buff, buff2);
}
END_TEST

START_TEST(sprintf_spec_float55) {
  // Check case with specificator %5.5G and big number
  double x = 122332483472728.4579;
  char buff[S21_MAX] = "";
  char buff2[S21_MAX] = "";
  sprintf(buff, "TEST5 %5.5G", x);
  s21_sprintf(buff2, "TEST5 %5.5G", x);
  ck_assert_str_eq(buff, buff2);
}
END_TEST

START_TEST(sprintf_spec_float56) {
  // Check case with specificator %LG
  long double x = 12.4579;
  char buff[S21_MAX] = "";
  char buff2[S21_MAX] = "";
  sprintf(buff, "TEST1 %LG", x);
  s21_sprintf(buff2, "TEST1 %LG", x);
  ck_assert_str_eq(buff, buff2);
}
END_TEST

START_TEST(sprintf_spec_float57) {
  // Check case with specificator %.LG
  long double x = 12.4579;
  char buff[S21_MAX] = "";
  char buff2[S21_MAX] = "";
  sprintf(buff, "TEST2 %.LG", x);
  s21_sprintf(buff2, "TEST2 %.LG", x);
  ck_assert_str_eq(buff, buff2);
}
END_TEST

START_TEST(sprintf_spec_float58) {
  // Check case with specificator %5LG
  long double x = 12.4579;
  char buff[S21_MAX] = "";
  char buff2[S21_MAX] = "";
  sprintf(buff, "TEST3 %5LG", x);
  s21_sprintf(buff2, "TEST3 %5LG", x);
  ck_assert_str_eq(buff, buff2);
}
END_TEST

START_TEST(sprintf_spec_float59) {
  // Check case with specificator %.5LG
  long double x = 12.4579;
  char buff[S21_MAX] = "";
  char buff2[S21_MAX] = "";
  sprintf(buff, "TEST4 %.5LG", x);
  s21_sprintf(buff2, "TEST4 %.5LG", x);
  ck_assert_str_eq(buff, buff2);
}
END_TEST

START_TEST(sprintf_spec_float60) {
  // Check case with specificator %5.5LG
  long double x = 12.4579;
  char buff[S21_MAX] = "";
  char buff2[S21_MAX] = "";
  sprintf(buff, "TEST5 %5.5LG", x);
  s21_sprintf(buff2, "TEST5 %5.5LG", x);
  ck_assert_str_eq(buff, buff2);
}
END_TEST

START_TEST(sprintf_spec_float61) {
  // Check flags combination with %+-#G
  double x = -12.4579;
  char buff[S21_MAX] = "";
  char buff2[S21_MAX] = "";
  sprintf(buff, "TEST1 %+-#G", x);
  s21_sprintf(buff2, "TEST1 %+-#G", x);
  ck_assert_str_eq(buff, buff2);
}
END_TEST

START_TEST(sprintf_spec_float62) {
  // Check flags combination with %+0G
  double x = -12.4579;
  char buff[S21_MAX] = "";
  char buff2[S21_MAX] = "";
  sprintf(buff, "TEST2 %+0G", x);
  s21_sprintf(buff2, "TEST2 %+0G", x);
  ck_assert_str_eq(buff, buff2);
}
END_TEST

START_TEST(sprintf_spec_float63) {
  // Check flags combination with %+-G
  double x = -12.4579;
  char buff[S21_MAX] = "";
  char buff2[S21_MAX] = "";
  sprintf(buff, "TEST3 %+-G", x);
  s21_sprintf(buff2, "TEST3 %+-G", x);
  ck_assert_str_eq(buff, buff2);
}
END_TEST

START_TEST(sprintf_spec_float64) {
  // Check flags combination with '%+0G'
  double x = -12.4579;
  char buff[S21_MAX] = "";
  char buff2[S21_MAX] = "";
  sprintf(buff, "TEST4 %+0G", x);
  s21_sprintf(buff2, "TEST4 %+0G", x);
  ck_assert_str_eq(buff, buff2);
}
END_TEST

START_TEST(sprintf_spec_float65) {
  // Check flags combination with '%- G'
  double x = -12.4579;
  char buff[S21_MAX] = "";
  char buff2[S21_MAX] = "";
  sprintf(buff, "TEST5 %- G", x);
  s21_sprintf(buff2, "TEST5 %- G", x);
  ck_assert_str_eq(buff, buff2);
}
END_TEST

START_TEST(sprintf_spec_float66) {
  // Check flags combination with '%+-#12G'
  double x = 12.4579;
  char buff[S21_MAX] = "";
  char buff2[S21_MAX] = "";
  sprintf(buff, "TEST1 %+-#12G", x);
  s21_sprintf(buff2, "TEST1 %+-#12G", x);
  ck_assert_str_eq(buff, buff2);
}
END_TEST

START_TEST(sprintf_spec_float67) {
  // Check flags combination with %03.11G
  double x = 12.4579;
  char buff[S21_MAX] = "";
  char buff2[S21_MAX] = "";
  sprintf(buff, "TEST2 %03.11G", x);
  s21_sprintf(buff2, "TEST2 %03.11G", x);
  ck_assert_str_eq(buff, buff2);
}
END_TEST

START_TEST(sprintf_spec_float68) {
  // Check flags combination with %+-.2G
  double x = 12.4579;
  char buff[S21_MAX] = "";
  char buff2[S21_MAX] = "";
  sprintf(buff, "TEST3 %+-.2G", x);
  s21_sprintf(buff2, "TEST3 %+-.2G", x);
  ck_assert_str_eq(buff, buff2);
}
END_TEST

START_TEST(sprintf_spec_float69) {
  // Check flags combination with %+04.2G
  double x = 12.4579;
  char buff[S21_MAX] = "";
  char buff2[S21_MAX] = "";
  sprintf(buff, "TEST4 %+04.2G", x);
  s21_sprintf(buff2, "TEST4 %+04.2G", x);
  ck_assert_str_eq(buff, buff2);
}
END_TEST

START_TEST(sprintf_spec_float70) {
  // Check flags combination with % .G
  double x = 12.4579;
  char buff[S21_MAX] = "";
  char buff2[S21_MAX] = "";
  sprintf(buff, "TEST5 % .G", x);
  s21_sprintf(buff2, "TEST5 % .G", x);
  ck_assert_str_eq(buff, buff2);
}
END_TEST

START_TEST(sprintf_spec_float71) {
  // Check flags combination with %+#012LG
  long double x = 12.4579;
  char buff[S21_MAX] = "";
  char buff2[S21_MAX] = "";
  sprintf(buff, "TEST1 %+#012LG", x);
  s21_sprintf(buff2, "TEST1 %+#012LG", x);
  ck_assert_str_eq(buff, buff2);
}
END_TEST

START_TEST(sprintf_spec_float72) {
  // Check flags combination with %-3.11LG
  long double x = 12.4579;
  char buff[S21_MAX] = "";
  char buff2[S21_MAX] = "";
  sprintf(buff, "TEST2 %-3.11LG", x);
  s21_sprintf(buff2, "TEST2 %-3.11LG", x);
  ck_assert_str_eq(buff, buff2);
}
END_TEST

START_TEST(sprintf_spec_float73) {
  // Check flags combination with %+-.2LG
  long double x = 12.4579;
  char buff[S21_MAX] = "";
  char buff2[S21_MAX] = "";
  sprintf(buff, "TEST3 %+-.2LG", x);
  s21_sprintf(buff2, "TEST3 %+-.2LG", x);
  ck_assert_str_eq(buff, buff2);
}
END_TEST

START_TEST(sprintf_spec_float74) {
  // Check flags combination with %+04.2LG
  long double x = 12.4579;
  char buff[S21_MAX] = "";
  char buff2[S21_MAX] = "";
  sprintf(buff, "TEST4 %+04.2LG", x);
  s21_sprintf(buff2, "TEST4 %+04.2LG", x);
  ck_assert_str_eq(buff, buff2);
}
END_TEST

START_TEST(sprintf_spec_float75) {
  // Check flags combination with %+.LG
  long double x = 12.4579;
  char buff[S21_MAX] = "";
  char buff2[S21_MAX] = "";
  sprintf(buff, "TEST5 %+.LG", x);
  s21_sprintf(buff2, "TEST5 %+.LG", x);
  ck_assert_str_eq(buff, buff2);
}
END_TEST

START_TEST(sprintf_spec_int1) {
  // Check one case
  int x = 1;
  char buff[S21_MAX] = "";
  char buff2[S21_MAX] = "";
  sprintf(buff, "All in %d piece.", x);
  s21_sprintf(buff2, "All in %d piece.", x);
  ck_assert_str_eq(buff, buff2);
}
END_TEST

START_TEST(sprintf_spec_int2) {
  // Check few cases
  int x = 10;
  int y = 1;
  char buff[S21_MAX] = "";
  char buff2[S21_MAX] = "";
  sprintf(buff, "%d to %d", x, y);
  s21_sprintf(buff2, "%d to %d", x, y);
  ck_assert_str_eq(buff, buff2);
}
END_TEST

START_TEST(sprintf_spec_int3) {
  // Check signed decimal integer
  int x = 12;
  char buff[S21_MAX] = "";
  char buff2[S21_MAX] = "";
  sprintf(buff, "Ten in the eighth number system - %i", x);
  s21_sprintf(buff2, "Ten in the eighth number system - %i", x);
  ck_assert_str_eq(buff, buff2);
}
END_TEST

START_TEST(sprintf_spec_int4) {
  // Check flag '+'
  int x = 156;
  char buff[S21_MAX] = "";
  char buff2[S21_MAX] = "";
  sprintf(buff, "%+d", x);
  s21_sprintf(buff2, "%+d", x);
  ck_assert_str_eq(buff, buff2);
}
END_TEST

START_TEST(sprintf_spec_int5) {
  // Check flag '0' and width
  int x = 156;
  char buff[S21_MAX] = "";
  char buff2[S21_MAX] = "";
  sprintf(buff, "%09d", x);
  s21_sprintf(buff2, "%09d", x);
  ck_assert_str_eq(buff, buff2);
}
END_TEST

START_TEST(sprintf_spec_int6) {
  // Check specificator
  int x = 156;
  char buff[S21_MAX] = "";
  char buff2[S21_MAX] = "";
  sprintf(buff, "%.9d", x);
  s21_sprintf(buff2, "%.9d", x);
  ck_assert_str_eq(buff, buff2);
}
END_TEST

START_TEST(sprintf_spec_int7) {
  // Check flag '-' and width
  int x = 156;
  char buff[S21_MAX] = "";
  char buff2[S21_MAX] = "";
  sprintf(buff, "%-3d", x);
  s21_sprintf(buff2, "%-3d", x);
  ck_assert_str_eq(buff, buff2);
}
END_TEST

START_TEST(sprintf_spec_int8) {
  // Check short int
  short int x = 16;
  char buff[S21_MAX] = "";
  char buff2[S21_MAX] = "";
  sprintf(buff, "%-3hd", x);
  s21_sprintf(buff2, "%-3hd", x);
  ck_assert_str_eq(buff, buff2);
}
END_TEST

START_TEST(sprintf_spec_int9) {
  // Check x = 0
  int x = 0;
  char buff[S21_MAX] = "";
  char buff2[S21_MAX] = "";
  sprintf(buff, "%-.d", x);
  s21_sprintf(buff2, "%-.d", x);
  ck_assert_str_eq(buff, buff2);
}
END_TEST

START_TEST(sprintf_spec_int10) {
  // Check x < 0
  int x = -32;
  char buff[S21_MAX] = "";
  char buff2[S21_MAX] = "";
  sprintf(buff, "%-.d", x);
  s21_sprintf(buff2, "%-.d", x);
  ck_assert_str_eq(buff, buff2);
}
END_TEST

START_TEST(sprintf_spec_int11) {
  // Check "*"
  int x = -32;
  int h = 5;
  char buff[S21_MAX] = "";
  char buff2[S21_MAX] = "";
  sprintf(buff, "%*.d", h, x);
  s21_sprintf(buff2, "%*.d", h, x);
  ck_assert_str_eq(buff, buff2);
}
END_TEST

START_TEST(sprintf_spec_pointer1) {
  // Testing basic pointer formatting
  char *x = "Hello, World!";
  char buff[S21_MAX] = "";
  char buff2[S21_MAX] = "";
  sprintf(buff, "TEST1 %p", x);
  s21_sprintf(buff2, "TEST1 %p", x);
  ck_assert_str_eq(buff, buff2);
}
END_TEST

START_TEST(sprintf_spec_pointer2) {
  // Testing multiple pointer format specifiers in one string
  char *x = "Hello, World!";
  char buff[S21_MAX] = "";
  char buff2[S21_MAX] = "";
  sprintf(buff, "TEST1 %p TEST2 %p", x, x);
  s21_sprintf(buff2, "TEST1 %p TEST2 %p", x, x);
  ck_assert_str_eq(buff, buff2);
}
END_TEST

START_TEST(sprintf_spec_pointer3) {
  // Testing width with pointer formatting
  char *x = "Hello, World!";
  char buff[S21_MAX] = "";
  char buff2[S21_MAX] = "";
  sprintf(buff, "TEST1 %13p", x);
  s21_sprintf(buff2, "TEST1 %13p", x);
  ck_assert_str_eq(buff, buff2);
}
END_TEST

START_TEST(sprintf_spec_pointer4) {
  // Testing non-NULL integer pointer formatting
  char sys[S21_MAX] = "";
  char s21[S21_MAX] = "";
  int value = 42;
  void *ptr = &value;
  sprintf(sys, "%p", ptr);
  s21_sprintf(s21, "%p", ptr);
  ck_assert_str_eq(sys, s21);
}
END_TEST

START_TEST(sprintf_spec_pointer5) {
  // Testing double pointer formatting
  char sys[S21_MAX] = "";
  char s21[S21_MAX] = "";
  double a = 123.456;
  sprintf(sys, "%p", &a);
  s21_sprintf(s21, "%p", &a);
  ck_assert_str_eq(sys, s21);
}
END_TEST

START_TEST(sprintf_spec_pointer6) {
  // Testing left-aligned width formatting with pointer
  char sys[S21_MAX] = "";
  char s21[S21_MAX] = "";
  double a = 123.456;
  sprintf(sys, "abc%-20p abc", &a);
  s21_sprintf(s21, "abc%-20p abc", &a);
  ck_assert_str_eq(sys, s21);
}
END_TEST

START_TEST(sprintf_spec_pointer7) {
  // Testing width formatting with pointer inside a string
  char sys[S21_MAX] = "";
  char s21[S21_MAX] = "";
  double a = 123.456;
  sprintf(sys, "abc%50p abc", &a);
  s21_sprintf(s21, "abc%50p abc", &a);
  ck_assert_str_eq(sys, s21);
}
END_TEST

START_TEST(sprintf_spec_pointer8) {
  // Testing width formatting with pointer
  char sys[S21_MAX] = "";
  char s21[S21_MAX] = "";
  double a = 123.456;
  sprintf(sys, "%50p", &a);
  s21_sprintf(s21, "%50p", &a);
  ck_assert_str_eq(sys, s21);
}
END_TEST

START_TEST(sprintf_spec_string1) {
  // Case one string
  char buff[S21_MAX] = "";
  char buff2[S21_MAX] = "";
  char str[S21_MAX] = "Hello to V.V.T.";
  sprintf(buff, "%s", str);
  s21_sprintf(buff2, "%s", str);
  ck_assert_str_eq(buff, buff2);
}
END_TEST

START_TEST(sprintf_spec_string2) {
  // Check width for string
  char str[S21_MAX] = "Hello to V.V.T.";
  char buff[S21_MAX] = "";
  char buff2[S21_MAX] = "";
  sprintf(buff, "%15s", str);
  s21_sprintf(buff2, "%15s", str);
  ck_assert_str_eq(buff, buff2);
}
END_TEST

START_TEST(sprintf_spec_string3) {
  // Check precision for string
  char str[S21_MAX] = "Hello to V.V.T.";
  char buff[S21_MAX] = "";
  char buff2[S21_MAX] = "";
  sprintf(buff, "%.15s", str);
  s21_sprintf(buff2, "%.15s", str);
  ck_assert_str_eq(buff, buff2);
}
END_TEST

START_TEST(sprintf_spec_string4) {
  // Check width and precision for string
  char str[S21_MAX] = "Hello to V.V.T.";
  char buff[S21_MAX] = "";
  char buff2[S21_MAX] = "";
  sprintf(buff, "%23.23s", str);
  s21_sprintf(buff2, "%23.23s", str);
  ck_assert_str_eq(buff, buff2);
}
END_TEST

START_TEST(sprintf_spec_string5) {
  // Check a lot strings
  char buff[S21_MAX] = "";
  char buff2[S21_MAX] = "";
  char str[S21_MAX] = "Hello to V.V.T.";
  sprintf(buff, "%s", str);
  s21_sprintf(buff2, "%s", str);
  ck_assert_str_eq(buff, buff2);
}
END_TEST

START_TEST(sprintf_spec_string6) {
  // Check a lot strings
  char buff[S21_MAX] = "";
  char buff2[S21_MAX] = "";
  char str2[S21_MAX] = "Let's play!";
  sprintf(buff, "%s", str2);
  s21_sprintf(buff2, "%s", str2);
  ck_assert_str_eq(buff, buff2);
}
END_TEST

START_TEST(sprintf_spec_string7) {
  // Check a lot strings
  char buff[S21_MAX] = "";
  char buff2[S21_MAX] = "";
  char str3[S21_MAX] = "Bye-bye!";
  sprintf(buff, "%s", str3);
  s21_sprintf(buff2, "%s", str3);
  ck_assert_str_eq(buff, buff2);
}
END_TEST

START_TEST(sprintf_spec_string8) {
  // Check wide char
  wchar_t str1[6] = L"QWER";
  char buff[S21_MAX] = "";
  char buff2[S21_MAX] = "";
  sprintf(buff, "%ls", str1);
  s21_sprintf(buff2, "%ls", str1);
  ck_assert_str_eq(buff, buff2);
}
END_TEST

START_TEST(sprintf_spec_string9) {
  // Check wide char
  wchar_t str2[6] = L"TY";
  char buff[S21_MAX] = "";
  char buff2[S21_MAX] = "";
  sprintf(buff, "%ls", str2);
  s21_sprintf(buff2, "%ls", str2);
  ck_assert_str_eq(buff, buff2);
}
END_TEST

START_TEST(sprintf_spec_string10) {
  //  4:    
  char buff[S21_MAX] = "";
  char buff2[S21_MAX] = "";
  char str[S21_MAX] = "Hello to V.V.T.";
  sprintf(buff, "%.5s", str);
  s21_sprintf(buff2, "%.5s", str);
  ck_assert_str_eq(buff, buff2);
}
END_TEST

START_TEST(sprintf_spec_string11) {
  // The width is greater than the length of the string
  char buff[S21_MAX] = "";
  char buff2[S21_MAX] = "";
  char str[S21_MAX] = "Hello";
  sprintf(buff, "%10s", str);
  s21_sprintf(buff2, "%10s", str);
  ck_assert_str_eq(buff, buff2);
}
END_TEST

START_TEST(sprintf_spec_string12) {
  //    '-'
  char buff[S21_MAX] = "";
  char buff2[S21_MAX] = "";
  char str[S21_MAX] = "Hello";
  sprintf(buff, "%-10s", str);
  s21_sprintf(buff2, "%-10s", str);
  ck_assert_str_eq(buff, buff2);
}
END_TEST

START_TEST(sprintf_spec_uint1) {
  // Check one case - u
  unsigned int x = 013;
  char buff[S21_MAX] = {0};
  char buff2[S21_MAX] = {0};
  sprintf(buff, "TEST1 %u TEST2 %u TEST3 %u TEST4 %u TEST5 %u", x, x, x, x, x);
  s21_sprintf(buff2, "TEST1 %u TEST2 %u TEST3 %u TEST4 %u TEST5 %u", x, x, x, x,
              x);
  ck_assert_str_eq(buff, buff2);
}
END_TEST

START_TEST(sprintf_spec_uint2) {
  // Check decimals parameters - u
  unsigned int x = 013;
  long unsigned int x1 = 124124334;
  long unsigned x2 = 1234562132123543;
  unsigned short x3 = 13;
  unsigned short x4 = 1123;
  char buff[S21_MAX] = {0};
  char buff2[S21_MAX] = {0};
  sprintf(buff, "TEST1 %u TEST2 %lu TEST3 %lu TEST4 %hu TEST5 %hu", x, x1, x2,
          x3, x4);
  s21_sprintf(buff2, "TEST1 %u TEST2 %lu TEST3 %lu TEST4 %hu TEST5 %hu", x, x1,
              x2, x3, x4);
  ck_assert_str_eq(buff, buff2);
}
END_TEST

START_TEST(sprintf_spec_uint3) {
  // Check width and precision - u
  unsigned int x = 12;
  char buff[S21_MAX] = {0};
  char buff2[S21_MAX] = {0};
  sprintf(buff, "TEST1 %3u TEST2 %.u TEST3 %.5u TEST4 %13.5u TEST5 %u", x, x, x,
          x, x);
  s21_sprintf(buff2, "TEST1 %3u TEST2 %.u TEST3 %.5u TEST4 %13.5u TEST5 %u", x,
              x, x, x, x);
  ck_assert_str_eq(buff, buff2);
}
END_TEST

START_TEST(sprintf_spec_uint4) {
  // Check flags - u
  unsigned int x = 12;
  char buff[S21_MAX] = {0};
  char buff2[S21_MAX] = {0};
  sprintf(buff, "TEST1 %-3u TEST2 %-.u TEST3 %.5u TEST4 %13.5u", x, x, x, x);
  s21_sprintf(buff2, "TEST1 %-3u TEST2 %-.u TEST3 %.5u TEST4 %13.5u", x, x, x,
              x);
  ck_assert_str_eq(buff, buff2);
}
END_TEST

START_TEST(sprintf_spec_uint5) {
  // Check "*" - u
  unsigned int x = 1332;
  int length = 9;
  char buff[S21_MAX] = {0};
  char buff2[S21_MAX] = {0};
  sprintf(buff, "TEST1 %*u TEST2 %.*u TEST3 %*.*u", length, x, length, x,
          length, length, x);
  s21_sprintf(buff2, "TEST1 %*u TEST2 %.*u TEST3 %*.*u", length, x, length, x,
              length, length, x);
  ck_assert_str_eq(buff, buff2);
}
END_TEST

START_TEST(sprintf_spec_uint6) {
  // Check one case - o
  int x = 0123;
  char buff[S21_MAX] = {0};
  char buff2[S21_MAX] = {0};
  sprintf(buff, "TEST1 %o TEST2 %o TEST3 %o TEST4 %o TEST5 %o", x, x, x, x, x);
  s21_sprintf(buff2, "TEST1 %o TEST2 %o TEST3 %o TEST4 %o TEST5 %o", x, x, x, x,
              x);
  ck_assert_str_eq(buff, buff2);
}
END_TEST

START_TEST(sprintf_spec_uint7) {
  // Check decimals parameters - o
  unsigned int x = 013;
  long unsigned int x1 = 124124334;
  long unsigned x2 = 1234562132123543;
  unsigned short x3 = 13;
  unsigned short x4 = 1123;
  char buff[S21_MAX] = {0};
  char buff2[S21_MAX] = {0};
  sprintf(buff, "TEST1 %o TEST2 %lo TEST3 %lo TEST4 %ho TEST5 %ho", x, x1, x2,
          x3, x4);
  s21_sprintf(buff2, "TEST1 %o TEST2 %lo TEST3 %lo TEST4 %ho TEST5 %ho", x, x1,
              x2, x3, x4);
  ck_assert_str_eq(buff, buff2);
}
END_TEST

START_TEST(sprintf_spec_uint8) {
  // Check width and precision - o
  int x = 12;
  char buff[S21_MAX] = {0};
  char buff2[S21_MAX] = {0};
  sprintf(buff, "TEST1 %3o TEST2 %.o TEST3 %.5o TEST4 %13.5o TEST5 %o", x, x, x,
          x, x);
  s21_sprintf(buff2, "TEST1 %3o TEST2 %.o TEST3 %.5o TEST4 %13.5o TEST5 %o", x,
              x, x, x, x);
  ck_assert_str_eq(buff, buff2);
}
END_TEST

START_TEST(sprintf_spec_uint9) {
  // Check flags - o
  int x = 12;
  char buff[S21_MAX] = {0};
  char buff2[S21_MAX] = {0};
  sprintf(buff, "TEST1 %-3o TEST2 %-.o TEST3 %.5o TEST4 %13.5o", x, x, x, x);
  s21_sprintf(buff2, "TEST1 %-3o TEST2 %-.o TEST3 %.5o TEST4 %13.5o", x, x, x,
              x);
  ck_assert_str_eq(buff, buff2);
}
END_TEST

START_TEST(sprintf_spec_uint10) {
  // Check "*" - o
  unsigned int x = 1332;
  int length = 9;
  char buff[S21_MAX] = {0};
  char buff2[S21_MAX] = {0};
  sprintf(buff, "TEST1 %*o TEST2 %.*o TEST3 %*.*o", length, x, length, x,
          length, length, x);
  s21_sprintf(buff2, "TEST1 %*o TEST2 %.*o TEST3 %*.*o", length, x, length, x,
              length, length, x);
  ck_assert_str_eq(buff, buff2);
}
END_TEST

START_TEST(sprintf_spec_uint11) {
  // Check one case - HEX
  int x = 13;
  char buff[S21_MAX] = {0};
  char buff2[S21_MAX] = {0};
  sprintf(buff, "TEST1 %x TEST2 %X TEST3 %x TEST4 %X TEST5 %x", x, x, x, x, x);
  s21_sprintf(buff2, "TEST1 %x TEST2 %X TEST3 %x TEST4 %X TEST5 %x", x, x, x, x,
              x);
  ck_assert_str_eq(buff, buff2);
}
END_TEST

START_TEST(sprintf_spec_uint12) {
  // Check decimals parameters - HEX
  unsigned int x = 013;
  long unsigned int x1 = 124124334;
  long unsigned x2 = 1234562132123543;
  unsigned short x3 = 13;
  unsigned short x4 = 1123;
  char buff[S21_MAX] = {0};
  char buff2[S21_MAX] = {0};
  sprintf(buff, "TEST1 %x TEST2 %lx TEST3 %lX TEST4 %hx TEST5 %hX", x, x1, x2,
          x3, x4);
  s21_sprintf(buff2, "TEST1 %x TEST2 %lx TEST3 %lX TEST4 %hx TEST5 %hX", x, x1,
              x2, x3, x4);
  ck_assert_str_eq(buff, buff2);
}
END_TEST

START_TEST(sprintf_spec_uint13) {
  // Check width and precision - HEX1
  int x = 12;
  char buff[S21_MAX] = {0};
  char buff2[S21_MAX] = {0};
  sprintf(buff, "TEST1 %3x TEST2 %.x TEST3 %.5x TEST4 %13.5x TEST5 %x", x, x, x,
          x, x);
  s21_sprintf(buff2, "TEST1 %3x TEST2 %.x TEST3 %.5x TEST4 %13.5x TEST5 %x", x,
              x, x, x, x);
  ck_assert_str_eq(buff, buff2);
}
END_TEST

START_TEST(sprintf_spec_uint14) {
  // Check width and precision - HEX2
  int x = 12;
  char buff[S21_MAX] = {0};
  char buff2[S21_MAX] = {0};
  sprintf(buff, "TEST1 %3X TEST2 %.X TEST3 %.5X TEST4 %13.5X TEST5 %X", x, x, x,
          x, x);
  s21_sprintf(buff2, "TEST1 %3X TEST2 %.X TEST3 %.5X TEST4 %13.5X TEST5 %X", x,
              x, x, x, x);
  ck_assert_str_eq(buff, buff2);
}
END_TEST

START_TEST(sprintf_spec_uint15) {
  // Check flags - HEX1
  int x = 12;
  char buff[S21_MAX] = {0};
  char buff2[S21_MAX] = {0};
  sprintf(buff, "TEST1 %-3x TEST2 %-.x TEST3 %.5x TEST4 %13.5x ", x, x, x, x);
  s21_sprintf(buff2, "TEST1 %-3x TEST2 %-.x TEST3 %.5x TEST4 %13.5x ", x, x, x,
              x);
  ck_assert_str_eq(buff, buff2);
}
END_TEST

START_TEST(sprintf_spec_uint16) {
  // Check flags - HEX2
  int x = 12;
  char buff[S21_MAX] = {0};
  char buff2[S21_MAX] = {0};
  sprintf(buff, "TEST1 %-3X TEST2 %-.X TEST3 %.5X TEST4 %13.5X", x, x, x, x);
  s21_sprintf(buff2, "TEST1 %-3X TEST2 %-.X TEST3 %.5X TEST4 %13.5X", x, x, x,
              x);
  ck_assert_str_eq(buff, buff2);
}
END_TEST

START_TEST(sprintf_spec_uint17) {
  // Check "*" - HEX1
  unsigned int x = 1332;
  int length = 9;
  char buff[S21_MAX] = {0};
  char buff2[S21_MAX] = {0};
  sprintf(buff, "TEST1 %*x TEST2 %.*x TEST3 %*.*x", length, x, length, x,
          length, length, x);
  s21_sprintf(buff2, "TEST1 %*x TEST2 %.*x TEST3 %*.*x", length, x, length, x,
              length, length, x);
  ck_assert_str_eq(buff, buff2);
}
END_TEST

START_TEST(sprintf_spec_uint18) {
  // Check "*" - HEX2
  unsigned int x = 1332;
  int length = 9;
  char buff[S21_MAX] = {0};
  char buff2[S21_MAX] = {0};
  sprintf(buff, "TEST1 %*X TEST2 %.*X TEST3 %*.*X", length, x, length, x,
          length, length, x);
  s21_sprintf(buff2, "TEST1 %*X TEST2 %.*X TEST3 %*.*X", length, x, length, x,
              length, length, x);
  ck_assert_str_eq(buff, buff2);
}
END_TEST

START_TEST(sprintf_spec_uint19) {
  // Check for the case when FlagStruct.zero is 'false', and FlagStruct.sharp is
  // 'true' '(%#x)'
  unsigned int x = 31;
  char buff[S21_MAX] = {0};
  char buff2[S21_MAX] = {0};
  sprintf(buff, "Case1 %#x", x);
  s21_sprintf(buff2, "Case1 %#x", x);
  ck_assert_str_eq(buff, buff2);
}
END_TEST

START_TEST(sprintf_spec_uint20) {
  // Check for the case when both FlagStruct.zero and FlagStruct.sharp are
  // 'true' '(%0#X)'
  unsigned int y = 29;
  char buff[S21_MAX] = {0};
  char buff2[S21_MAX] = {0};
  sprintf(buff, "Case2 %0#X", y);
  s21_sprintf(buff2, "Case2 %0#X", y);
  ck_assert_str_eq(buff, buff2);
}
END_TEST

START_TEST(sprintf_spec_uint21) {
  // Check for the case when only FlagStruct.sharp is 'true', and zero is not
  // there '(%#X)'
  unsigned int z = 27;
  char buff[S21_MAX] = {0};
  char buff2[S21_MAX] = {0};
  sprintf(buff, "Case3 %#X", z);
  s21_sprintf(buff2, "Case3 %#X", z);
  ck_assert_str_eq(buff, buff2);
}
END_TEST

START_TEST(sprintf_spec_uint22) {
  // Check for the case when both zero and sharp are there '(%0#x)'
  unsigned int a = 15;
  char buff[S21_MAX] = {0};
  char buff2[S21_MAX] = {0};
  sprintf(buff, "Case4 %0#x", a);
  s21_sprintf(buff2, "Case4 %0#x", a);
  ck_assert_str_eq(buff, buff2);
}
END_TEST

START_TEST(sprintf_spec_uint23) {
  // Check for the case when only FlagStruct.sharp is 'true' '(%#o)'
  unsigned int z = 15;
  char buff_o_sharp[S21_MAX] = {0};
  char buff2_o_sharp[S21_MAX] = {0};
  sprintf(buff_o_sharp, "CaseO %#o", z);
  s21_sprintf(buff2_o_sharp, "CaseO %#o", z);
  ck_assert_str_eq(buff_o_sharp, buff2_o_sharp);
}
END_TEST

START_TEST(sprintf_spec_uint24) {
  // Check for the case when both FlagStruct.zero and FlagStruct.sharp are
  // 'true' '(%0#o)'
  unsigned int zz = 15;
  char buff_o_sharp_zero[S21_MAX] = {0};
  char buff2_o_sharp_zero[S21_MAX] = {0};
  sprintf(buff_o_sharp_zero, "CaseOZero %0#o", zz);
  s21_sprintf(buff2_o_sharp_zero, "CaseOZero %0#o", zz);
  ck_assert_str_eq(buff_o_sharp_zero, buff2_o_sharp_zero);
}
END_TEST

START_TEST(sprintf_spec_combinations1) {
  // Check numbers cases
  int x1 = 10;
  double x2 = 10;
  char buff[S21_MAX] = {0};
  char buff2[S21_MAX] = {0};
  sprintf(buff,
          "Let's check num %d - double: %5.5f, exponent: %0e, short case: %g",
          x1, x2, x2, x2);
  s21_sprintf(
      buff2,
      "Let's check num %d - double: %5.5f, exponent: %0e, short case: %g", x1,
      x2, x2, x2);
  ck_assert_str_eq(buff, buff2);
}
END_TEST

START_TEST(sprintf_spec_combinations2) {
  // Check few more cases
  char *x1 = "Hello, World!";
  double x2 = 1478372.3222;
  char buff[S21_MAX] = {0};
  char buff2[S21_MAX] = {0};
  sprintf(buff, "Its pointer - %p. Lets check shorter way of num %f - %g", x1,
          x2, x2);
  s21_sprintf(buff2, "Its pointer - %p. Lets check shorter way of num %f - %g",
              x1, x2, x2);
  ck_assert_str_eq(buff, buff2);
}
END_TEST

START_TEST(strchr1) {
  // Check used symbol
  char str1[S21_MAX] = "Hello, world!";
  char c1 = 'w';
  ck_assert_pstr_eq(strchr(str1, c1), s21_strchr(str1, c1));
}
END_TEST

START_TEST(strchr2) {
  // Check unused symbol
  char str2[S21_MAX] = "Hello, world!";
  char c2 = 'P';
  ck_assert_pstr_eq(strchr(str2, c2), s21_strchr(str2, c2));
}
END_TEST

START_TEST(strchr3) {
  // Check empty string
  char str3[S21_MAX] = "";
  char c3 = 'H';
  ck_assert_pstr_eq(strchr(str3, c3), s21_strchr(str3, c3));
}
END_TEST

START_TEST(strchr4) {
  // Check space symbol
  char str4[S21_MAX] = "Hello, world!";
  char c4 = ' ';
  ck_assert_pstr_eq(strchr(str4, c4), s21_strchr(str4, c4));
}
END_TEST

START_TEST(strchr5) {
  // Check empty string and space symbol
  char str5[S21_MAX] = "";
  char c5 = ' ';
  ck_assert_pstr_eq(strchr(str5, c5), s21_strchr(str5, c5));
}
END_TEST

START_TEST(strchr6) {
  // Check NULL string
  char *str6 = NULL;
  char c6 = 'w';
  ck_assert_pstr_eq(s21_strchr(str6, c6), NULL);
}
END_TEST

START_TEST(strchr7) {
  // Check terminal null
  char str7[S21_MAX] = "Hello, world!";
  char c7 = '\0';
  ck_assert_pstr_eq(strchr(str7, c7), s21_strchr(str7, c7));
}
END_TEST

START_TEST(strchr8) {
  // Check NULL string and terminal null
  char *str8 = NULL;
  char c8 = '\0';
  ck_assert_pstr_eq(s21_strchr(str8, c8), NULL);
}
END_TEST

START_TEST(strcspn1) {
  // First string is empty
  char str1[] = "";
  char str2[] = "Hello, World!";
  ck_assert_int_eq(strcspn(str1, str2), s21_strcspn(str1, str2));
}
END_TEST

START_TEST(strcspn2) {
  // Second string is empty
  char str1[] = "Hello, World!";
  char str2[] = "";
  ck_assert_int_eq(strcspn(str1, str2), s21_strcspn(str1, str2));
}
END_TEST

START_TEST(strcspn3) {
  // Check different numbers string
  char str1[] = "5";
  char str2[] = "56";
  ck_assert_int_eq(strcspn(str1, str2), s21_strcspn(str1, str2));
}
END_TEST

START_TEST(strcspn4) {
  // Check same numbers string
  char str1[] = "70028131";
  char str2[] = "70028131";
  ck_assert_int_eq(strcspn(str1, str2), s21_strcspn(str1, str2));
}
END_TEST

START_TEST(strcspn5) {
  // Strings have different symbols
  char str1[] = "ADSFASFAS42312321";
  char str2[] = "0123894567";
  ck_assert_int_eq(strcspn(str1, str2), s21_strcspn(str1, str2));
}
END_TEST

START_TEST(strcspn6) {
  // Strings are empty
  char str1[] = "";
  char str2[] = "";
  ck_assert_int_eq(strcspn(str1, str2), s21_strcspn(str1, str2));
}
END_TEST

START_TEST(strcspn7) {
  // Check for " \0" and "\n\0"
  char str1[] = " \0";
  char str2[] = "\n\0";
  ck_assert_int_eq(strcspn(str1, str2), s21_strcspn(str1, str2));
}
END_TEST

START_TEST(strcspn8) {
  // Strings have different symbols
  char str1[] = "Hello, World!";
  char str2[] = "!";
  ck_assert_int_eq(strcspn(str1, str2), s21_strcspn(str1, str2));
}
END_TEST

START_TEST(strcspn9) {
  // Strings have different symbols
  char str1[] = "Hello, SChoOL!";
  char str2[] = "H!OLo";
  ck_assert_int_eq(strcspn(str1, str2), s21_strcspn(str1, str2));
}
END_TEST

START_TEST(strcspn10) {
  // Check if second string is NULL
  char str1[] = "Hello, World!";
  char *str2 = NULL;
  ck_assert_int_eq(0, s21_strcspn(str1, str2));
}
END_TEST

START_TEST(strcspn11) {
  // Check if first string is NULL
  char *str1 = NULL;
  char str2[] = "Hello, World!";
  ck_assert_int_eq(0, s21_strcspn(str1, str2));
}
END_TEST

START_TEST(strcspn12) {
  // Check for NULL
  char *str1 = NULL;
  char *str2 = NULL;
  ck_assert_int_eq(0, s21_strcspn(str1, str2));
}
END_TEST

START_TEST(strcspn13) {
  // Strings have no common symbols
  char str1[] = "Hello, World!";
  char str2[] = "1234567890";
  ck_assert_int_eq(strcspn(str1, str2), s21_strcspn(str1, str2));
}
END_TEST

START_TEST(strerror1) {
  // Invalid error code
  int err_num = SUM_ERRORS + 1;
  char *err_num1 = s21_strerror(err_num);
  char *err_num2 = strerror(err_num);
  ck_assert_str_eq(err_num1, err_num2);
}
END_TEST

START_TEST(strerror2) {
  // Test ensures functions match for valid error codes
  for (int i = 0; i < SUM_ERRORS; i++) {
    char *err_num1 = s21_strerror(i);
    char *err_num2 = strerror(i);
    ck_assert_str_eq(err_num1, err_num2);
  }
}
END_TEST

START_TEST(strlen1) {
  // normal string
  char str1[S21_MAX] = "hello world";
  ck_assert_int_eq(strlen(str1), s21_strlen(str1));
}
END_TEST

START_TEST(strlen2) {
  // empty string
  char str1[S21_MAX] = "";
  ck_assert_int_eq(strlen(str1), s21_strlen(str1));
}
END_TEST

START_TEST(strlen3) {
  // pointer
  char *str1 = "Hello is a World";
  ck_assert_int_eq(strlen(str1), s21_strlen(str1));
}
END_TEST

START_TEST(strlen4) {
  // NULL pointer
  char *str1 = NULL;
  ck_assert_msg(s21_strlen(str1) == 0,
                "s21_strlen should return 0 for NULL pointer");
}
END_TEST

START_TEST(strncat1) {
  // Insert full str2 lenth
  char str1[S21_MAX] = "Hello";
  char str2[S21_MAX] = " World!";
  ck_assert_ptr_eq(strncat(str1, str2, 7), s21_strncat(str1, str2, 7));
}
END_TEST

START_TEST(strncat2) {
  // Insert 4 characters of str2
  char str1[S21_MAX] = "Lorem";
  char str2[S21_MAX] = " Ipsum";
  ck_assert_ptr_eq(strncat(str1, str2, 4), s21_strncat(str1, str2, 4));
}
END_TEST

START_TEST(strncat3) {
  // Insert lenth > str2
  char str1[S21_MAX] = "Hello";
  char str2[S21_MAX] = " World!";
  ck_assert_ptr_eq(strncat(str1, str2, 15), s21_strncat(str1, str2, 15));
}
END_TEST

START_TEST(strncat4) {
  // Insert to empty string
  char str1[S21_MAX] = "";
  char str2[S21_MAX] = " Sup guys?";
  ck_assert_ptr_eq(strncat(str1, str2, 11), s21_strncat(str1, str2, 11));
}
END_TEST

START_TEST(strncat5) {
  // Insert empty string
  char str1[S21_MAX] = "qwerty";
  char str2[S21_MAX] = "";
  ck_assert_ptr_eq(strncat(str1, str2, 3), s21_strncat(str1, str2, 3));
}
END_TEST

START_TEST(strncat6) {
  // Insert to str1 with enough size
  char str_strncat[S21_MAX] = "qwerty";
  char str_s21_strncat[S21_MAX] = "qwerty";
  char str2[S21_MAX] = "uiop";
  s21_strncat(str_s21_strncat, str2, 4);
  strncat(str_strncat, str2, 4);
  ck_assert_str_eq(str_strncat, str_s21_strncat);
}
END_TEST

START_TEST(strncat7) {
  // Basic case
  char destin[S21_MAX] = "School";
  char destin2[S21_MAX] = "School";
  char extra[] = " 21";
  size_t max_len = sizeof(destin) - strlen(destin) - 1;
  ck_assert_str_eq(strncat(destin, extra, max_len),
                   s21_strncat(destin2, extra, max_len));
}
END_TEST

START_TEST(strncat8) {
  // Empty strs
  char destin[S21_MAX] = "";
  char destin2[S21_MAX] = "";
  char empty[S21_MAX] = "";
  size_t max_len = sizeof(destin) - strlen(destin) - 1;
  ck_assert_str_eq(strncat(destin, empty, max_len),
                   s21_strncat(destin2, empty, max_len));
}
END_TEST

START_TEST(strncat9) {
  // Extra doesnt fit into destination
  char destin[10] = "School";
  char destin2[10] = "School";
  char extra[] = " 21 is the best school!";
  size_t max_len = sizeof(destin) - strlen(destin) - 1;
  ck_assert_str_eq(strncat(destin, extra, max_len),
                   s21_strncat(destin2, extra, max_len));
}
END_TEST

START_TEST(strncat10) {
  // Insert str2 to NULL string
  char *str1 = NULL;
  char str2[S21_MAX] = " Ipsum";
  ck_assert_ptr_eq(NULL, s21_strncat(str1, str2, 4));
}
END_TEST

START_TEST(strncat11) {
  // Insert NULL to str1
  char str1[S21_MAX] = "Its me";
  char *str2 = NULL;
  ck_assert_ptr_eq(NULL, s21_strncat(str1, str2, 5));
}
END_TEST

START_TEST(strncmp1) {
  // Strings have same symbols
  char str1[S21_MAX] = "Hello, friend!";
  char substr1[S21_MAX] = "Hello, friend!";
  ck_assert_int_eq(strncmp(str1, substr1, S21_MAX),
                   s21_strncmp(str1, substr1, S21_MAX));
}
END_TEST

START_TEST(strncmp2) {
  // Strings have different words
  char str2[S21_MAX] = "Hello, friend!";
  char substr2[S21_MAX] = "Hello, Alex!";
  ck_assert_int_eq(strncmp(str2, substr2, S21_MAX),
                   s21_strncmp(str2, substr2, S21_MAX));
}
END_TEST

START_TEST(strncmp3) {
  // Strings have different symbols
  char str3[S21_MAX] = "Hello, Friend!";
  char substr3[S21_MAX] = "Hello, friend!";
  ck_assert_int_eq(strncmp(str3, substr3, S21_MAX),
                   s21_strncmp(str3, substr3, S21_MAX));
}
END_TEST

START_TEST(strncmp4) {
  // First string is empty
  char str4[S21_MAX] = "";
  char substr4[S21_MAX] = "Maddy";
  ck_assert_int_eq(strncmp(str4, substr4, S21_MAX),
                   s21_strncmp(str4, substr4, S21_MAX));
}
END_TEST

START_TEST(strncmp5) {
  // Second string is empty
  char str5[S21_MAX] = "Maddy";
  char substr5[S21_MAX] = "";
  ck_assert_int_eq(strncmp(str5, substr5, S21_MAX),
                   s21_strncmp(str5, substr5, S21_MAX));
}
END_TEST

START_TEST(strncmp6) {
  // Only first n characters should be compared
  char str6[S21_MAX] = "Hello, friend!";
  char substr6[S21_MAX] = "Hello, Alex!";
  ck_assert_int_eq(strncmp(str6, substr6, 5), s21_strncmp(str6, substr6, 5));
}
END_TEST

START_TEST(strncmp7) {
  // n is 0
  char str7[S21_MAX] = "Hello, friend!";
  char substr7[S21_MAX] = "Hello, Alex!";
  ck_assert_int_eq(strncmp(str7, substr7, 0), s21_strncmp(str7, substr7, 0));
}
END_TEST

START_TEST(strncmp8) {
  // One of the strings is NULL
  char str8[S21_MAX] = "Hello, friend!";
  char *substr8 = NULL;
  ck_assert_int_eq(S21_ERROR, s21_strncmp(str8, substr8, S21_MAX));
}
END_TEST

START_TEST(strncmp9) {
  // First string is NULL
  char *str9 = NULL;
  char substr9[S21_MAX] = "Hello, friend!";
  ck_assert_int_eq(S21_ERROR, s21_strncmp(str9, substr9, S21_MAX));
}
END_TEST

START_TEST(strncpy1) {
  char str1[50] = "ABCDEF";
  char str2[50] = "12345";
  ck_assert_str_eq(strncpy(str1, str2, 1), s21_strncpy(str1, str2, 1));
}
END_TEST

START_TEST(strncpy2) {
  char str1[50] = "Hi, School 21!";
  char str2[50] = "Hi, School 21!";
  char str3[] = "bye-bye!";
  s21_size_t n = 10;
  ck_assert_str_eq(strncpy(str1, str3, n), s21_strncpy(str2, str3, n));
}
END_TEST

START_TEST(strncpy3) {
  char str1[50] = "ABCDEF";
  char str2[50] = "12345";
  char str3[] = "GOOD";
  s21_size_t n = 5;
  ck_assert_str_eq(strncpy(str1, str3, n), s21_strncpy(str2, str3, n));
}
END_TEST

START_TEST(strncpy4) {
  char str1[50] = " *o0.";
  char str2[50] = "  -U_U- ";
  char str3[50] = " *o0.";
  char str4[50] = "  -U_U- ";
  ck_assert_str_eq(strncpy(str1, str2, 3), s21_strncpy(str3, str4, 3));
}
END_TEST

START_TEST(strncpy5) {
  char str1[50] = "     ABCDEF   ";
  char str2[50] = "12345";
  ck_assert_str_eq(strncpy(str1, str2, 9), s21_strncpy(str1, str2, 9));
}
END_TEST

START_TEST(strncpy6) {
  char str1[50] = "\v/n\0/r";
  char str2[50] = "4y/>\\9\0";
  ck_assert_str_eq(strncpy(str1, str2, 15), s21_strncpy(str1, str2, 15));
}
END_TEST

START_TEST(strncpy7) {
  char str1[50] = "   dest   ";
  char str2[50] = "S21_SCHOOL";
  ck_assert_str_eq(strncpy(str1, str2, 5), s21_strncpy(str1, str2, 5));
}
END_TEST

START_TEST(strncpy8) {
  // Source string is NULL
  char str1[50] = "Hello, world!";
  char *str2 = NULL;
  ck_assert_ptr_eq(NULL, s21_strncpy(str1, str2, 5));
}
END_TEST

START_TEST(strncpy9) {
  // Destination string is NULL
  char *str1 = NULL;
  char str2[50] = "Hello, world!";
  ck_assert_ptr_eq(NULL, s21_strncpy(str1, str2, 5));
}
END_TEST

START_TEST(strpbrk1) {
  // search for the correct character
  char str4[S21_MAX] = "tabt1/tcdt2/teft3/tght4";
  char symb[S21_MAX] = "/";
  ck_assert_ptr_eq(strpbrk(str4, symb), s21_strpbrk(str4, symb));
}
END_TEST

START_TEST(strpbrk2) {
  // search for an invalid character
  char str4[S21_MAX] = "tabt1/tcdt2/teft3/tght4";
  char symb[S21_MAX] = ".";
  ck_assert_ptr_eq(strpbrk(str4, symb), s21_strpbrk(str4, symb));
}
END_TEST

START_TEST(strpbrk3) {
  // Searching for multiple characters
  char str3[S21_MAX] = "Hello, world!";
  char symb3[S21_MAX] = "ld";
  ck_assert_ptr_eq(strpbrk(str3, symb3), s21_strpbrk(str3, symb3));
}
END_TEST

START_TEST(strpbrk4) {
  // Searching in an empty string
  char str4[S21_MAX] = "";
  char symb4[S21_MAX] = "H";
  ck_assert_ptr_eq(strpbrk(str4, symb4), s21_strpbrk(str4, symb4));
}
END_TEST

START_TEST(strpbrk5) {
  // Searching for an empty set of symbols
  char str5[S21_MAX] = "Hello, world!";
  char symb5[S21_MAX] = "";
  ck_assert_ptr_eq(strpbrk(str5, symb5), s21_strpbrk(str5, symb5));
}
END_TEST

START_TEST(strpbrk6) {
  // Searching in a NULL string
  char *str6 = NULL;
  char symb6[S21_MAX] = "H";
  ck_assert_ptr_eq(s21_strpbrk(str6, symb6), NULL);
}
END_TEST

START_TEST(strpbrk7) {
  // Searching for a NULL set of symbols
  char str7[S21_MAX] = "Hello, world!";
  char *symb7 = NULL;
  ck_assert_ptr_eq(s21_strpbrk(str7, symb7), NULL);
}
END_TEST

START_TEST(strpbrk8) {
  // Searching for multiple characters, some of which are not in the string
  char str8[S21_MAX] = "Hello, world!";
  char symb8[S21_MAX] = "xyzH";
  ck_assert_ptr_eq(strpbrk(str8, symb8), s21_strpbrk(str8, symb8));
}
END_TEST

START_TEST(strpbrk9) {
  // Searching for a symbol at the end of the string
  char str9[S21_MAX] = "Hello, world!";
  char symb9[S21_MAX] = "!";
  ck_assert_ptr_eq(strpbrk(str9, symb9), s21_strpbrk(str9, symb9));
}
END_TEST

START_TEST(strpbrk10) {
  // Searching for a symbol at the beginning of the string
  char str10[S21_MAX] = "Hello, world!";
  char symb10[S21_MAX] = "H";
  ck_assert_ptr_eq(strpbrk(str10, symb10), s21_strpbrk(str10, symb10));
}
END_TEST

START_TEST(strrchr1) {
  // last occurrence of a valid character
  char str1[S21_MAX] = "hello world";
  int symbol = 'l';
  ck_assert_ptr_eq(strrchr(str1, symbol), s21_strrchr(str1, symbol));
}
END_TEST

START_TEST(strrchr2) {
  // last occurrence of invalid character
  char str1[S21_MAX] = "hello world";
  int symbol = 'a';
  ck_assert_ptr_eq(strrchr(str1, symbol), s21_strrchr(str1, symbol));
}
END_TEST

START_TEST(strrchr3) {
  // Empty string, character not found
  char str3[S21_MAX] = "";
  int symbol3 = 'a';
  ck_assert_ptr_eq(strrchr(str3, symbol3), s21_strrchr(str3, symbol3));
}
END_TEST

START_TEST(strrchr4) {
  // Empty string, character found at the beginning
  char str4[S21_MAX] = "";
  int symbol4 = '\0';
  ck_assert_ptr_eq(strrchr(str4, symbol4), s21_strrchr(str4, symbol4));
}
END_TEST

START_TEST(strrchr5) {
  // Empty string, character found at the end
  char str5[S21_MAX] = "";
  int symbol5 = '\0';
  ck_assert_ptr_eq(strrchr(str5, symbol5), s21_strrchr(str5, symbol5));
}
END_TEST

START_TEST(strrchr6) {
  // Character found in a string with multiple occurrences
  char str6[S21_MAX] = "hello world";
  int symbol6 = 'o';
  ck_assert_ptr_eq(strrchr(str6, symbol6), s21_strrchr(str6, symbol6));
}
END_TEST

START_TEST(strrchr7) {
  // Character not found in a string with multiple occurrences
  char str7[S21_MAX] = "hello world";
  int symbol7 = 'z';
  ck_assert_ptr_eq(strrchr(str7, symbol7), s21_strrchr(str7, symbol7));
}
END_TEST

START_TEST(strrchr8) {
  // Character found at the beginning of a string
  char str8[S21_MAX] = "hello world";
  int symbol8 = 'h';
  ck_assert_ptr_eq(strrchr(str8, symbol8), s21_strrchr(str8, symbol8));
}
END_TEST

START_TEST(strrchr9) {
  // Character found at the end of a string
  char str9[S21_MAX] = "hello world";
  int symbol9 = 'd';
  ck_assert_ptr_eq(strrchr(str9, symbol9), s21_strrchr(str9, symbol9));
}
END_TEST

START_TEST(strrchr10) {
  // Check NULL string
  char *str10 = NULL;
  int symbol10 = 'h';
  ck_assert_ptr_eq(s21_strrchr(str10, symbol10), NULL);
}
END_TEST

START_TEST(strrchr11) {
  // Check NULL string and terminal null
  char *str11 = NULL;
  int symbol11 = '\0';
  ck_assert_ptr_eq(s21_strrchr(str11, symbol11), NULL);
}
END_TEST

START_TEST(strrchr12) {
  // Check symbol not found in numeric string
  char str12[S21_MAX] = "1234567890";
  int symbol12 = 'a';
  ck_assert_ptr_eq(strrchr(str12, symbol12), s21_strrchr(str12, symbol12));
}
END_TEST

START_TEST(strrchr13) {
  // Check symbol found in numeric string
  char str13[S21_MAX] = "1234567890";
  int symbol13 = '5';
  ck_assert_ptr_eq(strrchr(str13, symbol13), s21_strrchr(str13, symbol13));
}
END_TEST

START_TEST(strstr1) {
  // Substring found at the beginning of the string
  char str1[S21_MAX] = "Hello, world!";
  char substr1[S21_MAX] = "Hello";
  ck_assert_ptr_eq(strstr(str1, substr1), s21_strstr(str1, substr1));
}
END_TEST

START_TEST(strstr2) {
  // Substring found in the middle of the string
  char str2[S21_MAX] = "Hello, world!";
  char substr2[S21_MAX] = "world";
  ck_assert_ptr_eq(strstr(str2, substr2), s21_strstr(str2, substr2));
}
END_TEST

START_TEST(strstr3) {
  // Substring found at the end of the string
  char str3[S21_MAX] = "Hello, world!";
  char substr3[S21_MAX] = "!";
  ck_assert_ptr_eq(strstr(str3, substr3), s21_strstr(str3, substr3));
}
END_TEST

START_TEST(strstr4) {
  // Empty string as the haystack
  char str4[S21_MAX] = "";
  char substr4[S21_MAX] = "world";
  ck_assert_ptr_eq(strstr(str4, substr4), s21_strstr(str4, substr4));
}
END_TEST

START_TEST(strstr5) {
  // Empty string as the needle
  char str5[S21_MAX] = "Hello, world!";
  char substr5[S21_MAX] = "";
  ck_assert_ptr_eq(strstr(str5, substr5), s21_strstr(str5, substr5));
}
END_TEST

START_TEST(strstr6) {
  // Substring not found in the string
  char str6[S21_MAX] = "Hello, world!";
  char substr6[S21_MAX] = "school";
  ck_assert_ptr_eq(strstr(str6, substr6), s21_strstr(str6, substr6));
}
END_TEST

START_TEST(strstr7) {
  // NULL as the haystack
  char *str7 = NULL;
  char substr7[S21_MAX] = "world";
  ck_assert_ptr_eq(s21_strstr(str7, substr7), NULL);
}
END_TEST

START_TEST(strstr8) {
  // NULL as the needle
  char str8[S21_MAX] = "Hello, world!";
  char *substr8 = NULL;
  ck_assert_ptr_eq(s21_strstr(str8, substr8), NULL);
}
END_TEST

START_TEST(strstr9) {
  // Both haystack and needle are NULL
  char *str9 = NULL;
  char *substr9 = NULL;
  ck_assert_ptr_eq(s21_strstr(str9, substr9), NULL);
}
END_TEST

START_TEST(strtok1) {
  // Testing tokenization with mixed delimiters
  char str1[S21_MAX] = "This is test/string.for!get lexemes";
  char str2[S21_MAX] = "This is test/string.for!get lexemes";
  char delim[S21_MAX] = "/. ";
  char *new_str1 = strtok(str1, delim);
  char *new_str2 = s21_strtok(str2, delim);
  while (new_str1 != NULL) {
    ck_assert_pstr_eq(new_str1, new_str2);
    new_str1 = strtok(NULL, delim);
    new_str2 = s21_strtok(NULL, delim);
  }
}
END_TEST

START_TEST(strtok2) {
  // Testing tokenization with repeated delimiters
  char str1[S21_MAX] = "/test1 test2/////test3 test4/test5";
  char str2[S21_MAX] = "/test1 test2/////test3 test4/test5";
  char delim[S21_MAX] = "/";
  char *new_str1 = strtok(str1, delim);
  char *new_str2 = s21_strtok(str2, delim);
  while (new_str1 != NULL) {
    ck_assert_pstr_eq(new_str1, new_str2);
    new_str1 = strtok(NULL, delim);
    new_str2 = s21_strtok(NULL, delim);
  }
}
END_TEST

START_TEST(strtok3) {
  // Testing tokenization until NULL return
  char str1[S21_MAX] = "test1/test2";
  char str2[S21_MAX] = "test1/test2";
  char delim[S21_MAX] = "/";
  char *new_str1 = strtok(str1, delim);
  char *new_str2 = s21_strtok(str2, delim);
  ck_assert_pstr_eq(new_str1, new_str2);
  new_str1 = strtok(NULL, delim);
  new_str2 = s21_strtok(NULL, delim);
  ck_assert_pstr_eq(new_str1, new_str2);
  new_str1 = strtok(NULL, delim);
  new_str2 = s21_strtok(NULL, delim);
}
END_TEST

START_TEST(strtok4) {
  // Testing tokenization on an empty string
  char str1[S21_MAX] = "";
  char str2[S21_MAX] = "";
  char delim[S21_MAX] = "/. ";
  char *new_str1 = strtok(str1, delim);
  char *new_str2 = s21_strtok(str2, delim);
  ck_assert_pstr_eq(new_str1, new_str2);
}
END_TEST

START_TEST(strtok5) {
  // Testing tokenization with correct delimiter
  char str3[S21_MAX] = "tabt1/tcdt2/teft3/tght4";
  char str4[S21_MAX] = "tabt1/tcdt2/teft3/tght4";
  char del[] = "/";
  ck_assert_pstr_eq(strtok(str3, del), s21_strtok(str4, del));
}
END_TEST

START_TEST(strtok6) {
  // Testing tokenization with invalid delimiter
  char str3[S21_MAX] = "tabt1/tcdt2/teft3/tght4";
  char str4[S21_MAX] = "tabt1/tcdt2/teft3/tght4";
  char del[] = ".";
  ck_assert_pstr_eq(strtok(str3, del), s21_strtok(str4, del));
}
END_TEST

START_TEST(strtok7) {
  // Testing tokenization with multiple delimiters
  char str3[S21_MAX] = "tabt1/tcdt2/teft3/tght4";
  char str4[S21_MAX] = "tabt1/tcdt2/teft3/tght4";
  char del[] = "t/";
  ck_assert_pstr_eq(strtok(str3, del), s21_strtok(str4, del));
}
END_TEST

START_TEST(strtok8) {
  // Testing tokenization with special characters in delimiters
  char str3[S21_MAX] = "tabt1/tcdt2/teft3/tght4";
  char str4[S21_MAX] = "tabt1/tcdt2/teft3/tght4";
  char del[] = "t/?";
  ck_assert_pstr_eq(strtok(str3, del), s21_strtok(str4, del));
}
END_TEST

START_TEST(strtok9) {
  // Testing tokenization with a combination of special characters and
  // alphanumeric characters in delimiters
  char str3[S21_MAX] = "tabt1/tcdt2/teft3/tght4";
  char str4[S21_MAX] = "tabt1/tcdt2/teft3/tght4";
  char del[] = "%t/?";
  ck_assert_pstr_eq(strtok(str3, del), s21_strtok(str4, del));
}
END_TEST

START_TEST(strtok10) {
  // Testing tokenization with a string that has no delimiters
  char str3[] = "NoDelimiter";
  char str4[] = "NoDelimiter";
  char *delim = ",";
  ck_assert_pstr_eq(s21_strtok(str4, delim), strtok(str3, delim));
}
END_TEST

START_TEST(strtok11) {
  // Testing tokenization with an empty string and a delimiter
  char str3[] = "";
  char str4[] = "";
  char *delim = ",";
  ck_assert_pstr_eq(s21_strtok(str4, delim), strtok(str3, delim));
}
END_TEST

START_TEST(strtok12) {
  // Testing tokenization with NULL string
  char *str1 = NULL;
  char delim[S21_MAX] = "/. ";
  char *new_str1 = s21_strtok(str1, delim);
  ck_assert_ptr_eq(new_str1, NULL);
}
END_TEST

START_TEST(strtok13) {
  // Testing tokenization with empty delimiter
  char str1[S21_MAX] = "This is test string";
  char delim[] = "";
  char *new_str1 = s21_strtok(str1, delim);
  ck_assert_pstr_eq(new_str1, str1);
}
END_TEST

START_TEST(strtok14) {
  // Testing tokenization with NULL delimiter
  char str1[S21_MAX] = "This is test string";
  char *delim = NULL;
  char *new_str1 = s21_strtok(str1, delim);
  ck_assert_pstr_eq(new_str1, str1);
}
END_TEST

START_TEST(strtok15) {
  // Testing tokenization with both NULL string and NULL delimiter
  char *str1 = NULL;
  char *delim = NULL;
  char *new_str1 = s21_strtok(str1, delim);
  ck_assert_ptr_eq(new_str1, NULL);
}
END_TEST

START_TEST(to_lower1) {
  // From uppercase to lowercase
  char str1[] = "HELLO WORLD";
  char *transformed = s21_to_lower(str1);
  ck_assert_str_eq(transformed, "hello world");
  free(transformed);
}
END_TEST

START_TEST(to_lower2) {
  // From lowercase to lowercase
  char str2[] = "hello world";
  char *transformed = s21_to_lower(str2);
  ck_assert_str_eq(transformed, "hello world");
  free(transformed);
}
END_TEST

START_TEST(to_lower3) {
  // Numbers remain unchanged
  char str3[] = "1234567890";
  char *transformed = s21_to_lower(str3);
  ck_assert_str_eq(transformed, "1234567890");
  free(transformed);
}
END_TEST

START_TEST(to_lower4) {
  // Empty string
  char *str4 = NULL;
  char *transformed = s21_to_lower(str4);
  ck_assert_ptr_eq(transformed, NULL);
}
END_TEST

START_TEST(to_lower5) {
  // Special characters remain unchanged
  char str5[] = " \t\n";
  char *transformed = s21_to_lower(str5);
  ck_assert_str_eq(transformed, " \t\n");
  free(transformed);
}
END_TEST

START_TEST(to_lower6) {
  // Mixed case to lowercase
  char str6[] = "HeLlO WoRlD";
  char *transformed = s21_to_lower(str6);
  ck_assert_str_eq(transformed, "hello world");
  free(transformed);
}
END_TEST

START_TEST(to_upper1) {
  // From lowercase to uppercase
  char str7[] = "hello world";
  char *transformed = s21_to_upper(str7);
  ck_assert_str_eq(transformed, "HELLO WORLD");
  free(transformed);
}
END_TEST

START_TEST(to_upper2) {
  // From uppercase to uppercase
  char str8[] = "HELLO WORLD";
  char *transformed = s21_to_upper(str8);
  ck_assert_str_eq(transformed, "HELLO WORLD");
  free(transformed);
}
END_TEST

START_TEST(to_upper3) {
  // Digits
  char str9[] = "1234567890";
  char *transformed = s21_to_upper(str9);
  ck_assert_str_eq(transformed, "1234567890");
  free(transformed);
}
END_TEST

START_TEST(to_upper4) {
  // Empty string
  char *str10 = NULL;
  char *transformed = s21_to_upper(str10);
  ck_assert_ptr_eq(transformed, NULL);
}
END_TEST

START_TEST(to_upper5) {
  // Special characters
  char str11[] = " \t\n";
  char *transformed = s21_to_upper(str11);
  ck_assert_str_eq(transformed, " \t\n");
  free(transformed);
}
END_TEST

START_TEST(to_upper6) {
  // Mixed case
  char str12[] = "HeLlO WoRlD";
  char *transformed = s21_to_upper(str12);
  ck_assert_str_eq(transformed, "HELLO WORLD");
  free(transformed);
}
END_TEST

START_TEST(trim1) {
  // Input null trim
  char *triming = "\t\nSchool 21\t\n";
  char *test_trim = NULL;
  char *exp_result = "School 21";
  char *result = (char *)s21_trim(triming, test_trim);
  ck_assert_str_eq(result, exp_result);
  if (result) {
    free(result);
  }
}
END_TEST

START_TEST(trim2) {
  // Input one trim
  char *triming = "\t\nSchool 21\t\n";
  char *test_trim = "\t";
  char *exp_result = "\nSchool 21\t\n";
  char *result = (char *)s21_trim(triming, test_trim);
  ck_assert_str_eq(result, exp_result);
  if (result) {
    free(result);
  }
}
END_TEST

START_TEST(trim3) {
  // Input two trims
  char *triming = "\t\nSchool 21\t\n";
  char *test_trim = "\t\n";
  char *exp_result = "School 21";
  char *result = (char *)s21_trim(triming, test_trim);
  ck_assert_str_eq(result, exp_result);
  if (result) {
    free(result);
  }
}
END_TEST

START_TEST(trim4) {
  // Input not in trim
  char *triming = "\t\nSchool 21\t\n";
  char *test_trim = " ";
  char *exp_result = "\t\nSchool 21\t\n";
  char *result = (char *)s21_trim(triming, test_trim);
  ck_assert_str_eq(result, exp_result);
  if (result) {
    free(result);
  }
}
END_TEST

START_TEST(trim5) {
  // Input empty string
  char *triming = "";
  char *test_trim = "\t\n";
  char *exp_result = "";
  char *result = (char *)s21_trim(triming, test_trim);
  ck_assert_str_eq(result, exp_result);
  if (result) {
    free(result);
  }
}
END_TEST

START_TEST(trim6) {
  // Input string with only trim characters
  char *triming = "\t\t\t\n\n\n";
  char *test_trim = "\t\n";
  char *exp_result = "";
  char *result = (char *)s21_trim(triming, test_trim);
  ck_assert_str_eq(result, exp_result);
  if (result) {
    free(result);
  }
}
END_TEST

START_TEST(trim7) {
  // Input string without trim characters
  char *triming = "School 21";
  char *test_trim = "\t\n";
  char *exp_result = "School 21";
  char *result = (char *)s21_trim(triming, test_trim);
  ck_assert_str_eq(result, exp_result);
  if (result) {
    free(result);
  }
}
END_TEST

START_TEST(uitoa1) {
  // Test conversion of large unsigned integer value to string in base 10.
  unsigned long long value = 1234567890;
  int base = 10;
  char outputString[50];
  char *result = util_uitoa(value, outputString, base);
  ck_assert_str_eq(result, "1234567890");
}
END_TEST

START_TEST(uitoa2) {
  // Test conversion of hexadecimal value to string in base 16.
  unsigned long long value = 0xABCDEF;
  int base = 16;
  char outputString[50];
  char *result = util_uitoa(value, outputString, base);
  ck_assert_str_eq(result, "ABCDEF");
}
END_TEST

START_TEST(uitoa3) {
  // Test conversion of zero value to string in base 10.
  unsigned long long value = 0;
  int base = 10;
  char outputString[50];
  char *result = util_uitoa(value, outputString, base);
  ck_assert_str_eq(result, "0");
}
END_TEST

START_TEST(uitoa4) {
  // Test conversion of zero value to string in base 10.
  unsigned long long value = 0;
  int base = 10;
  char outputString[50];
  char *result = util_uitoa(value, outputString, base);
  ck_assert_str_eq(result, "0");
}
END_TEST

START_TEST(uitoa5) {
  // Test conversion of a large unsigned long long value to string in base 10.
  unsigned long long value = 1234567890123456789ULL;
  int base = 10;
  char outputString[64];
  char *result = util_uitoa(value, outputString, base);
  ck_assert_str_eq(result, "1234567890123456789");
}
END_TEST

int main(void) {
  Suite *s1 = suite_create("count_digits");
  TCase *tc1_1 = tcase_create("count_digits");
  Suite *s2 = suite_create("util_double_to_str");
  TCase *tc2_1 = tcase_create("util_double_to_str");
  Suite *s3 = suite_create("find_exponent");
  TCase *tc3_1 = tcase_create("find_exponent");
  Suite *s4 = suite_create("util_hex_to_dec");
  TCase *tc4_1 = tcase_create("util_hex_to_dec");
  Suite *s5 = suite_create("insert");
  TCase *tc5_1 = tcase_create("insert");
  Suite *s6 = suite_create("itoa");
  TCase *tc6_1 = tcase_create("itoa");
  Suite *s7 = suite_create("memchr");
  TCase *tc7_1 = tcase_create("memchr");
  Suite *s8 = suite_create("memcmp");
  TCase *tc8_1 = tcase_create("memcmp");
  Suite *s9 = suite_create("memcpy");
  TCase *tc9_1 = tcase_create("memcpy");
  Suite *s10 = suite_create("memset");
  TCase *tc10_1 = tcase_create("memset");
  Suite *s11 = suite_create("util_reverse");
  TCase *tc11_1 = tcase_create("util_reverse");
  Suite *s12 = suite_create("rounding_double");
  TCase *tc12_1 = tcase_create("rounding_double");
  Suite *s13 = suite_create("sprintf_spec_char");
  TCase *tc13_1 = tcase_create("sprintf_spec_char");
  Suite *s14 = suite_create("sprintf_spec_double");
  TCase *tc14_1 = tcase_create("sprintf_spec_double");
  Suite *s15 = suite_create("sprintf_spec_exponent");
  TCase *tc15_1 = tcase_create("sprintf_spec_exponent");
  Suite *s16 = suite_create("sprintf_spec_float");
  TCase *tc16_1 = tcase_create("sprintf_spec_float");
  Suite *s17 = suite_create("sprintf_spec_int");
  TCase *tc17_1 = tcase_create("sprintf_spec_int");
  Suite *s18 = suite_create("sprintf_spec_pointer");
  TCase *tc18_1 = tcase_create("sprintf_spec_pointer");
  Suite *s19 = suite_create("sprintf_spec_string");
  TCase *tc19_1 = tcase_create("sprintf_spec_string");
  Suite *s20 = suite_create("sprintf_spec_uint");
  TCase *tc20_1 = tcase_create("sprintf_spec_uint");
  Suite *s21 = suite_create("sprintf_spec_combinations");
  TCase *tc21_1 = tcase_create("sprintf_spec_combinations");
  Suite *s22 = suite_create("strchr");
  TCase *tc22_1 = tcase_create("strchr");
  Suite *s23 = suite_create("strcspn");
  TCase *tc23_1 = tcase_create("strcspn");
  Suite *s24 = suite_create("strerror");
  TCase *tc24_1 = tcase_create("strerror");
  Suite *s25 = suite_create("strlen");
  TCase *tc25_1 = tcase_create("strlen");
  Suite *s26 = suite_create("strncat");
  TCase *tc26_1 = tcase_create("strncat");
  Suite *s27 = suite_create("strncmp");
  TCase *tc27_1 = tcase_create("strncmp");
  Suite *s28 = suite_create("strncpy");
  TCase *tc28_1 = tcase_create("strncpy");
  Suite *s29 = suite_create("strpbrk");
  TCase *tc29_1 = tcase_create("strpbrk");
  Suite *s30 = suite_create("strrchr");
  TCase *tc30_1 = tcase_create("strrchr");
  Suite *s31 = suite_create("strstr");
  TCase *tc31_1 = tcase_create("strstr");
  Suite *s32 = suite_create("strtok");
  TCase *tc32_1 = tcase_create("strtok");
  Suite *s33 = suite_create("to_lower");
  TCase *tc33_1 = tcase_create("to_lower");
  Suite *s34 = suite_create("to_upper");
  TCase *tc34_1 = tcase_create("to_upper");
  Suite *s35 = suite_create("trim");
  TCase *tc35_1 = tcase_create("trim");
  Suite *s36 = suite_create("uitoa");
  TCase *tc36_1 = tcase_create("uitoa");
  SRunner *sr = srunner_create(s1);
  int nf;

  suite_add_tcase(s1, tc1_1);
  tcase_add_test(tc1_1, count_digits1);
  tcase_add_test(tc1_1, count_digits2);
  tcase_add_test(tc1_1, count_digits3);
  tcase_add_test(tc1_1, count_digits4);
  suite_add_tcase(s2, tc2_1);
  tcase_add_test(tc2_1, double_to_str1);
  tcase_add_test(tc2_1, double_to_str2);
  tcase_add_test(tc2_1, double_to_str3);
  tcase_add_test(tc2_1, double_to_str4);
  tcase_add_test(tc2_1, double_to_str5);
  tcase_add_test(tc2_1, double_to_str6);
  suite_add_tcase(s3, tc3_1);
  tcase_add_test(tc3_1, find_exponent1);
  tcase_add_test(tc3_1, find_exponent2);
  tcase_add_test(tc3_1, find_exponent3);
  tcase_add_test(tc3_1, find_exponent4);
  suite_add_tcase(s4, tc4_1);
  tcase_add_test(tc4_1, hex_to_dec1);
  tcase_add_test(tc4_1, hex_to_dec2);
  tcase_add_test(tc4_1, hex_to_dec3);
  tcase_add_test(tc4_1, hex_to_dec4);
  tcase_add_test(tc4_1, hex_to_dec5);
  tcase_add_test(tc4_1, hex_to_dec6);
  tcase_add_test(tc4_1, hex_to_dec7);
  tcase_add_test(tc4_1, hex_to_dec8);
  suite_add_tcase(s5, tc5_1);
  tcase_add_test(tc5_1, insert1);
  tcase_add_test(tc5_1, insert2);
  tcase_add_test(tc5_1, insert3);
  tcase_add_test(tc5_1, insert4);
  tcase_add_test(tc5_1, insert5);
  tcase_add_test(tc5_1, insert6);
  tcase_add_test(tc5_1, insert7);
  tcase_add_test(tc5_1, insert8);
  tcase_add_test(tc5_1, insert9);
  tcase_add_test(tc5_1, insert10);
  tcase_add_test(tc5_1, insert11);
  suite_add_tcase(s6, tc6_1);
  tcase_add_test(tc6_1, itoa1);
  tcase_add_test(tc6_1, itoa2);
  tcase_add_test(tc6_1, itoa3);
  tcase_add_test(tc6_1, itoa4);
  tcase_add_test(tc6_1, itoa5);
  tcase_add_test(tc6_1, itoa6);
  tcase_add_test(tc6_1, itoa7);
  tcase_add_test(tc6_1, itoa8);
  tcase_add_test(tc6_1, itoa9);
  tcase_add_test(tc6_1, itoa10);
  tcase_add_test(tc6_1, itoa11);
  tcase_add_test(tc6_1, itoa12);
  tcase_add_test(tc6_1, itoa13);
  tcase_add_test(tc6_1, itoa14);
  tcase_add_test(tc6_1, itoa15);
  tcase_add_test(tc6_1, itoa16);
  tcase_add_test(tc6_1, itoa17);
  tcase_add_test(tc6_1, itoa18);
  tcase_add_test(tc6_1, itoa19);
  tcase_add_test(tc6_1, itoa20);
  tcase_add_test(tc6_1, itoa21);
  tcase_add_test(tc6_1, itoa22);
  tcase_add_test(tc6_1, itoa23);
  tcase_add_test(tc6_1, itoa24);
  tcase_add_test(tc6_1, itoa25);
  tcase_add_test(tc6_1, itoa26);
  tcase_add_test(tc6_1, itoa27);
  tcase_add_test(tc6_1, itoa28);
  tcase_add_test(tc6_1, itoa29);
  tcase_add_test(tc6_1, itoa30);
  tcase_add_test(tc6_1, itoa31);
  tcase_add_test(tc6_1, itoa32);
  tcase_add_test(tc6_1, itoa33);
  tcase_add_test(tc6_1, itoa34);
  tcase_add_test(tc6_1, itoa35);
  tcase_add_test(tc6_1, itoa36);
  suite_add_tcase(s7, tc7_1);
  tcase_add_test(tc7_1, memchr1);
  tcase_add_test(tc7_1, memchr2);
  tcase_add_test(tc7_1, memchr3);
  tcase_add_test(tc7_1, memchr4);
  tcase_add_test(tc7_1, memchr5);
  tcase_add_test(tc7_1, memchr6);
  tcase_add_test(tc7_1, memchr7);
  tcase_add_test(tc7_1, memchr8);
  tcase_add_test(tc7_1, memchr9);
  tcase_add_test(tc7_1, memchr10);
  suite_add_tcase(s8, tc8_1);
  tcase_add_test(tc8_1, memcmp1);
  tcase_add_test(tc8_1, memcmp2);
  tcase_add_test(tc8_1, memcmp3);
  tcase_add_test(tc8_1, memcmp4);
  tcase_add_test(tc8_1, memcmp5);
  tcase_add_test(tc8_1, memcmp6);
  tcase_add_test(tc8_1, memcmp7);
  tcase_add_test(tc8_1, memcmp8);
  tcase_add_test(tc8_1, memcmp9);
  tcase_add_test(tc8_1, memcmp10);
  suite_add_tcase(s9, tc9_1);
  tcase_add_test(tc9_1, memcpy1);
  tcase_add_test(tc9_1, memcpy2);
  tcase_add_test(tc9_1, memcpy3);
  tcase_add_test(tc9_1, memcpy4);
  tcase_add_test(tc9_1, memcpy5);
  tcase_add_test(tc9_1, memcpy6);
  tcase_add_test(tc9_1, memcpy7);
  tcase_add_test(tc9_1, memcpy8);
  tcase_add_test(tc9_1, memcpy9);
  tcase_add_test(tc9_1, memcpy10);
  tcase_add_test(tc9_1, memcpy11);
  suite_add_tcase(s10, tc10_1);
  tcase_add_test(tc10_1, memset1);
  tcase_add_test(tc10_1, memset2);
  tcase_add_test(tc10_1, memset3);
  tcase_add_test(tc10_1, memset4);
  tcase_add_test(tc10_1, memset5);
  tcase_add_test(tc10_1, memset6);
  tcase_add_test(tc10_1, memset7);
  tcase_add_test(tc10_1, memset8);
  tcase_add_test(tc10_1, memset9);
  tcase_add_test(tc10_1, memset10);
  tcase_add_test(tc10_1, memset11);
  tcase_add_test(tc10_1, memset12);
  tcase_add_test(tc10_1, memset13);
  suite_add_tcase(s11, tc11_1);
  tcase_add_test(tc11_1, reverse1);
  tcase_add_test(tc11_1, reverse2);
  tcase_add_test(tc11_1, reverse3);
  tcase_add_test(tc11_1, reverse4);
  tcase_add_test(tc11_1, reverse5);
  tcase_add_test(tc11_1, reverse6);
  suite_add_tcase(s12, tc12_1);
  tcase_add_test(tc12_1, rounding_double1);
  tcase_add_test(tc12_1, rounding_double2);
  tcase_add_test(tc12_1, rounding_double3);
  tcase_add_test(tc12_1, rounding_double4);
  tcase_add_test(tc12_1, rounding_double5);
  tcase_add_test(tc12_1, rounding_double6);
  tcase_add_test(tc12_1, rounding_double7);
  suite_add_tcase(s13, tc13_1);
  tcase_add_test(tc13_1, sprintf_spec_char1);
  tcase_add_test(tc13_1, sprintf_spec_char2);
  tcase_add_test(tc13_1, sprintf_spec_char3);
  tcase_add_test(tc13_1, sprintf_spec_char4);
  tcase_add_test(tc13_1, sprintf_spec_char5);
  suite_add_tcase(s14, tc14_1);
  tcase_add_test(tc14_1, sprintf_spec_double1);
  tcase_add_test(tc14_1, sprintf_spec_double2);
  tcase_add_test(tc14_1, sprintf_spec_double3);
  tcase_add_test(tc14_1, sprintf_spec_double4);
  tcase_add_test(tc14_1, sprintf_spec_double5);
  tcase_add_test(tc14_1, sprintf_spec_double6);
  tcase_add_test(tc14_1, sprintf_spec_double7);
  tcase_add_test(tc14_1, sprintf_spec_double8);
  tcase_add_test(tc14_1, sprintf_spec_double9);
  tcase_add_test(tc14_1, sprintf_spec_double10);
  tcase_add_test(tc14_1, sprintf_spec_double11);
  tcase_add_test(tc14_1, sprintf_spec_double12);
  suite_add_tcase(s15, tc15_1);
  tcase_add_test(tc15_1, sprintf_spec_exponent1);
  tcase_add_test(tc15_1, sprintf_spec_exponent2);
  tcase_add_test(tc15_1, sprintf_spec_exponent3);
  tcase_add_test(tc15_1, sprintf_spec_exponent4);
  tcase_add_test(tc15_1, sprintf_spec_exponent5);
  tcase_add_test(tc15_1, sprintf_spec_exponent6);
  tcase_add_test(tc15_1, sprintf_spec_exponent7);
  tcase_add_test(tc15_1, sprintf_spec_exponent8);
  tcase_add_test(tc15_1, sprintf_spec_exponent9);
  tcase_add_test(tc15_1, sprintf_spec_exponent10);
  tcase_add_test(tc15_1, sprintf_spec_exponent11);
  tcase_add_test(tc15_1, sprintf_spec_exponent12);
  tcase_add_test(tc15_1, sprintf_spec_exponent13);
  tcase_add_test(tc15_1, sprintf_spec_exponent14);
  tcase_add_test(tc15_1, sprintf_spec_exponent15);
  tcase_add_test(tc15_1, sprintf_spec_exponent16);
  tcase_add_test(tc15_1, sprintf_spec_exponent17);
  tcase_add_test(tc15_1, sprintf_spec_exponent18);
  tcase_add_test(tc15_1, sprintf_spec_exponent19);
  tcase_add_test(tc15_1, sprintf_spec_exponent20);
  tcase_add_test(tc15_1, sprintf_spec_exponent21);
  tcase_add_test(tc15_1, sprintf_spec_exponent22);
  tcase_add_test(tc15_1, sprintf_spec_exponent23);
  tcase_add_test(tc15_1, sprintf_spec_exponent24);
  tcase_add_test(tc15_1, sprintf_spec_exponent25);
  tcase_add_test(tc15_1, sprintf_spec_exponent26);
  tcase_add_test(tc15_1, sprintf_spec_exponent27);
  tcase_add_test(tc15_1, sprintf_spec_exponent28);
  tcase_add_test(tc15_1, sprintf_spec_exponent29);
  tcase_add_test(tc15_1, sprintf_spec_exponent30);
  tcase_add_test(tc15_1, sprintf_spec_exponent31);
  tcase_add_test(tc15_1, sprintf_spec_exponent32);
  tcase_add_test(tc15_1, sprintf_spec_exponent33);
  tcase_add_test(tc15_1, sprintf_spec_exponent34);
  tcase_add_test(tc15_1, sprintf_spec_exponent35);
  tcase_add_test(tc15_1, sprintf_spec_exponent36);
  tcase_add_test(tc15_1, sprintf_spec_exponent37);
  tcase_add_test(tc15_1, sprintf_spec_exponent38);
  tcase_add_test(tc15_1, sprintf_spec_exponent39);
  tcase_add_test(tc15_1, sprintf_spec_exponent40);
  tcase_add_test(tc15_1, sprintf_spec_exponent41);
  tcase_add_test(tc15_1, sprintf_spec_exponent42);
  tcase_add_test(tc15_1, sprintf_spec_exponent43);
  tcase_add_test(tc15_1, sprintf_spec_exponent44);
  tcase_add_test(tc15_1, sprintf_spec_exponent45);
  tcase_add_test(tc15_1, sprintf_spec_exponent46);
  tcase_add_test(tc15_1, sprintf_spec_exponent47);
  tcase_add_test(tc15_1, sprintf_spec_exponent48);
  tcase_add_test(tc15_1, sprintf_spec_exponent49);
  tcase_add_test(tc15_1, sprintf_spec_exponent50);
  tcase_add_test(tc15_1, sprintf_spec_exponent51);
  tcase_add_test(tc15_1, sprintf_spec_exponent52);
  tcase_add_test(tc15_1, sprintf_spec_exponent53);
  tcase_add_test(tc15_1, sprintf_spec_exponent54);
  tcase_add_test(tc15_1, sprintf_spec_exponent55);
  tcase_add_test(tc15_1, sprintf_spec_exponent56);
  tcase_add_test(tc15_1, sprintf_spec_exponent57);
  tcase_add_test(tc15_1, sprintf_spec_exponent58);
  tcase_add_test(tc15_1, sprintf_spec_exponent59);
  tcase_add_test(tc15_1, sprintf_spec_exponent60);
  tcase_add_test(tc15_1, sprintf_spec_exponent61);
  tcase_add_test(tc15_1, sprintf_spec_exponent62);
  tcase_add_test(tc15_1, sprintf_spec_exponent63);
  tcase_add_test(tc15_1, sprintf_spec_exponent64);
  tcase_add_test(tc15_1, sprintf_spec_exponent65);
  tcase_add_test(tc15_1, sprintf_spec_exponent66);
  tcase_add_test(tc15_1, sprintf_spec_exponent67);
  tcase_add_test(tc15_1, sprintf_spec_exponent68);
  tcase_add_test(tc15_1, sprintf_spec_exponent69);
  tcase_add_test(tc15_1, sprintf_spec_exponent70);
  tcase_add_test(tc15_1, sprintf_spec_exponent71);
  tcase_add_test(tc15_1, sprintf_spec_exponent72);
  tcase_add_test(tc15_1, sprintf_spec_exponent73);
  tcase_add_test(tc15_1, sprintf_spec_exponent74);
  tcase_add_test(tc15_1, sprintf_spec_exponent75);
  tcase_add_test(tc15_1, sprintf_spec_exponent76);
  tcase_add_test(tc15_1, sprintf_spec_exponent77);
  tcase_add_test(tc15_1, sprintf_spec_exponent78);
  suite_add_tcase(s16, tc16_1);
  tcase_add_test(tc16_1, sprintf_spec_float1);
  tcase_add_test(tc16_1, sprintf_spec_float2);
  tcase_add_test(tc16_1, sprintf_spec_float3);
  tcase_add_test(tc16_1, sprintf_spec_float4);
  tcase_add_test(tc16_1, sprintf_spec_float5);
  tcase_add_test(tc16_1, sprintf_spec_float6);
  tcase_add_test(tc16_1, sprintf_spec_float7);
  tcase_add_test(tc16_1, sprintf_spec_float8);
  tcase_add_test(tc16_1, sprintf_spec_float9);
  tcase_add_test(tc16_1, sprintf_spec_float10);
  tcase_add_test(tc16_1, sprintf_spec_float11);
  tcase_add_test(tc16_1, sprintf_spec_float12);
  tcase_add_test(tc16_1, sprintf_spec_float13);
  tcase_add_test(tc16_1, sprintf_spec_float14);
  tcase_add_test(tc16_1, sprintf_spec_float15);
  tcase_add_test(tc16_1, sprintf_spec_float16);
  tcase_add_test(tc16_1, sprintf_spec_float17);
  tcase_add_test(tc16_1, sprintf_spec_float18);
  tcase_add_test(tc16_1, sprintf_spec_float19);
  tcase_add_test(tc16_1, sprintf_spec_float20);
  tcase_add_test(tc16_1, sprintf_spec_float21);
  tcase_add_test(tc16_1, sprintf_spec_float22);
  tcase_add_test(tc16_1, sprintf_spec_float23);
  tcase_add_test(tc16_1, sprintf_spec_float24);
  tcase_add_test(tc16_1, sprintf_spec_float25);
  tcase_add_test(tc16_1, sprintf_spec_float26);
  tcase_add_test(tc16_1, sprintf_spec_float27);
  tcase_add_test(tc16_1, sprintf_spec_float28);
  tcase_add_test(tc16_1, sprintf_spec_float29);
  tcase_add_test(tc16_1, sprintf_spec_float30);
  tcase_add_test(tc16_1, sprintf_spec_float31);
  tcase_add_test(tc16_1, sprintf_spec_float32);
  tcase_add_test(tc16_1, sprintf_spec_float33);
  tcase_add_test(tc16_1, sprintf_spec_float34);
  tcase_add_test(tc16_1, sprintf_spec_float35);
  tcase_add_test(tc16_1, sprintf_spec_float36);
  tcase_add_test(tc16_1, sprintf_spec_float37);
  tcase_add_test(tc16_1, sprintf_spec_float38);
  tcase_add_test(tc16_1, sprintf_spec_float39);
  tcase_add_test(tc16_1, sprintf_spec_float40);
  tcase_add_test(tc16_1, sprintf_spec_float41);
  tcase_add_test(tc16_1, sprintf_spec_float42);
  tcase_add_test(tc16_1, sprintf_spec_float43);
  tcase_add_test(tc16_1, sprintf_spec_float44);
  tcase_add_test(tc16_1, sprintf_spec_float45);
  tcase_add_test(tc16_1, sprintf_spec_float46);
  tcase_add_test(tc16_1, sprintf_spec_float47);
  tcase_add_test(tc16_1, sprintf_spec_float48);
  tcase_add_test(tc16_1, sprintf_spec_float49);
  tcase_add_test(tc16_1, sprintf_spec_float50);
  tcase_add_test(tc16_1, sprintf_spec_float51);
  tcase_add_test(tc16_1, sprintf_spec_float52);
  tcase_add_test(tc16_1, sprintf_spec_float53);
  tcase_add_test(tc16_1, sprintf_spec_float54);
  tcase_add_test(tc16_1, sprintf_spec_float55);
  tcase_add_test(tc16_1, sprintf_spec_float56);
  tcase_add_test(tc16_1, sprintf_spec_float57);
  tcase_add_test(tc16_1, sprintf_spec_float58);
  tcase_add_test(tc16_1, sprintf_spec_float59);
  tcase_add_test(tc16_1, sprintf_spec_float60);
  tcase_add_test(tc16_1, sprintf_spec_float61);
  tcase_add_test(tc16_1, sprintf_spec_float62);
  tcase_add_test(tc16_1, sprintf_spec_float63);
  tcase_add_test(tc16_1, sprintf_spec_float64);
  tcase_add_test(tc16_1, sprintf_spec_float65);
  tcase_add_test(tc16_1, sprintf_spec_float66);
  tcase_add_test(tc16_1, sprintf_spec_float67);
  tcase_add_test(tc16_1, sprintf_spec_float68);
  tcase_add_test(tc16_1, sprintf_spec_float69);
  tcase_add_test(tc16_1, sprintf_spec_float70);
  tcase_add_test(tc16_1, sprintf_spec_float71);
  tcase_add_test(tc16_1, sprintf_spec_float72);
  tcase_add_test(tc16_1, sprintf_spec_float73);
  tcase_add_test(tc16_1, sprintf_spec_float74);
  tcase_add_test(tc16_1, sprintf_spec_float75);
  suite_add_tcase(s17, tc17_1);
  tcase_add_test(tc17_1, sprintf_spec_int1);
  tcase_add_test(tc17_1, sprintf_spec_int2);
  tcase_add_test(tc17_1, sprintf_spec_int3);
  tcase_add_test(tc17_1, sprintf_spec_int4);
  tcase_add_test(tc17_1, sprintf_spec_int5);
  tcase_add_test(tc17_1, sprintf_spec_int6);
  tcase_add_test(tc17_1, sprintf_spec_int7);
  tcase_add_test(tc17_1, sprintf_spec_int8);
  tcase_add_test(tc17_1, sprintf_spec_int9);
  tcase_add_test(tc17_1, sprintf_spec_int10);
  tcase_add_test(tc17_1, sprintf_spec_int11);
  suite_add_tcase(s18, tc18_1);
  tcase_add_test(tc18_1, sprintf_spec_pointer1);
  tcase_add_test(tc18_1, sprintf_spec_pointer2);
  tcase_add_test(tc18_1, sprintf_spec_pointer3);
  tcase_add_test(tc18_1, sprintf_spec_pointer4);
  tcase_add_test(tc18_1, sprintf_spec_pointer5);
  tcase_add_test(tc18_1, sprintf_spec_pointer6);
  tcase_add_test(tc18_1, sprintf_spec_pointer7);
  tcase_add_test(tc18_1, sprintf_spec_pointer8);
  suite_add_tcase(s19, tc19_1);
  tcase_add_test(tc19_1, sprintf_spec_string1);
  tcase_add_test(tc19_1, sprintf_spec_string2);
  tcase_add_test(tc19_1, sprintf_spec_string3);
  tcase_add_test(tc19_1, sprintf_spec_string4);
  tcase_add_test(tc19_1, sprintf_spec_string5);
  tcase_add_test(tc19_1, sprintf_spec_string6);
  tcase_add_test(tc19_1, sprintf_spec_string7);
  tcase_add_test(tc19_1, sprintf_spec_string8);
  tcase_add_test(tc19_1, sprintf_spec_string9);
  tcase_add_test(tc19_1, sprintf_spec_string10);
  tcase_add_test(tc19_1, sprintf_spec_string11);
  tcase_add_test(tc19_1, sprintf_spec_string12);
  suite_add_tcase(s20, tc20_1);
  tcase_add_test(tc20_1, sprintf_spec_uint1);
  tcase_add_test(tc20_1, sprintf_spec_uint2);
  tcase_add_test(tc20_1, sprintf_spec_uint3);
  tcase_add_test(tc20_1, sprintf_spec_uint4);
  tcase_add_test(tc20_1, sprintf_spec_uint5);
  tcase_add_test(tc20_1, sprintf_spec_uint6);
  tcase_add_test(tc20_1, sprintf_spec_uint7);
  tcase_add_test(tc20_1, sprintf_spec_uint8);
  tcase_add_test(tc20_1, sprintf_spec_uint9);
  tcase_add_test(tc20_1, sprintf_spec_uint10);
  tcase_add_test(tc20_1, sprintf_spec_uint11);
  tcase_add_test(tc20_1, sprintf_spec_uint12);
  tcase_add_test(tc20_1, sprintf_spec_uint13);
  tcase_add_test(tc20_1, sprintf_spec_uint14);
  tcase_add_test(tc20_1, sprintf_spec_uint15);
  tcase_add_test(tc20_1, sprintf_spec_uint16);
  tcase_add_test(tc20_1, sprintf_spec_uint17);
  tcase_add_test(tc20_1, sprintf_spec_uint18);
  tcase_add_test(tc20_1, sprintf_spec_uint19);
  tcase_add_test(tc20_1, sprintf_spec_uint20);
  tcase_add_test(tc20_1, sprintf_spec_uint21);
  tcase_add_test(tc20_1, sprintf_spec_uint22);
  tcase_add_test(tc20_1, sprintf_spec_uint23);
  tcase_add_test(tc20_1, sprintf_spec_uint24);
  suite_add_tcase(s21, tc21_1);
  tcase_add_test(tc21_1, sprintf_spec_combinations1);
  tcase_add_test(tc21_1, sprintf_spec_combinations2);
  suite_add_tcase(s22, tc22_1);
  tcase_add_test(tc22_1, strchr1);
  tcase_add_test(tc22_1, strchr2);
  tcase_add_test(tc22_1, strchr3);
  tcase_add_test(tc22_1, strchr4);
  tcase_add_test(tc22_1, strchr5);
  tcase_add_test(tc22_1, strchr6);
  tcase_add_test(tc22_1, strchr7);
  tcase_add_test(tc22_1, strchr8);
  suite_add_tcase(s23, tc23_1);
  tcase_add_test(tc23_1, strcspn1);
  tcase_add_test(tc23_1, strcspn2);
  tcase_add_test(tc23_1, strcspn3);
  tcase_add_test(tc23_1, strcspn4);
  tcase_add_test(tc23_1, strcspn5);
  tcase_add_test(tc23_1, strcspn6);
  tcase_add_test(tc23_1, strcspn7);
  tcase_add_test(tc23_1, strcspn8);
  tcase_add_test(tc23_1, strcspn9);
  tcase_add_test(tc23_1, strcspn10);
  tcase_add_test(tc23_1, strcspn11);
  tcase_add_test(tc23_1, strcspn12);
  tcase_add_test(tc23_1, strcspn13);
  suite_add_tcase(s24, tc24_1);
  tcase_add_test(tc24_1, strerror1);
  tcase_add_test(tc24_1, strerror2);
  suite_add_tcase(s25, tc25_1);
  tcase_add_test(tc25_1, strlen1);
  tcase_add_test(tc25_1, strlen2);
  tcase_add_test(tc25_1, strlen3);
  tcase_add_test(tc25_1, strlen4);
  suite_add_tcase(s26, tc26_1);
  tcase_add_test(tc26_1, strncat1);
  tcase_add_test(tc26_1, strncat2);
  tcase_add_test(tc26_1, strncat3);
  tcase_add_test(tc26_1, strncat4);
  tcase_add_test(tc26_1, strncat5);
  tcase_add_test(tc26_1, strncat6);
  tcase_add_test(tc26_1, strncat7);
  tcase_add_test(tc26_1, strncat8);
  tcase_add_test(tc26_1, strncat9);
  tcase_add_test(tc26_1, strncat10);
  tcase_add_test(tc26_1, strncat11);
  suite_add_tcase(s27, tc27_1);
  tcase_add_test(tc27_1, strncmp1);
  tcase_add_test(tc27_1, strncmp2);
  tcase_add_test(tc27_1, strncmp3);
  tcase_add_test(tc27_1, strncmp4);
  tcase_add_test(tc27_1, strncmp5);
  tcase_add_test(tc27_1, strncmp6);
  tcase_add_test(tc27_1, strncmp7);
  tcase_add_test(tc27_1, strncmp8);
  tcase_add_test(tc27_1, strncmp9);
  suite_add_tcase(s28, tc28_1);
  tcase_add_test(tc28_1, strncpy1);
  tcase_add_test(tc28_1, strncpy2);
  tcase_add_test(tc28_1, strncpy3);
  tcase_add_test(tc28_1, strncpy4);
  tcase_add_test(tc28_1, strncpy5);
  tcase_add_test(tc28_1, strncpy6);
  tcase_add_test(tc28_1, strncpy7);
  tcase_add_test(tc28_1, strncpy8);
  tcase_add_test(tc28_1, strncpy9);
  suite_add_tcase(s29, tc29_1);
  tcase_add_test(tc29_1, strpbrk1);
  tcase_add_test(tc29_1, strpbrk2);
  tcase_add_test(tc29_1, strpbrk3);
  tcase_add_test(tc29_1, strpbrk4);
  tcase_add_test(tc29_1, strpbrk5);
  tcase_add_test(tc29_1, strpbrk6);
  tcase_add_test(tc29_1, strpbrk7);
  tcase_add_test(tc29_1, strpbrk8);
  tcase_add_test(tc29_1, strpbrk9);
  tcase_add_test(tc29_1, strpbrk10);
  suite_add_tcase(s30, tc30_1);
  tcase_add_test(tc30_1, strrchr1);
  tcase_add_test(tc30_1, strrchr2);
  tcase_add_test(tc30_1, strrchr3);
  tcase_add_test(tc30_1, strrchr4);
  tcase_add_test(tc30_1, strrchr5);
  tcase_add_test(tc30_1, strrchr6);
  tcase_add_test(tc30_1, strrchr7);
  tcase_add_test(tc30_1, strrchr8);
  tcase_add_test(tc30_1, strrchr9);
  tcase_add_test(tc30_1, strrchr10);
  tcase_add_test(tc30_1, strrchr11);
  tcase_add_test(tc30_1, strrchr12);
  tcase_add_test(tc30_1, strrchr13);
  suite_add_tcase(s31, tc31_1);
  tcase_add_test(tc31_1, strstr1);
  tcase_add_test(tc31_1, strstr2);
  tcase_add_test(tc31_1, strstr3);
  tcase_add_test(tc31_1, strstr4);
  tcase_add_test(tc31_1, strstr5);
  tcase_add_test(tc31_1, strstr6);
  tcase_add_test(tc31_1, strstr7);
  tcase_add_test(tc31_1, strstr8);
  tcase_add_test(tc31_1, strstr9);
  suite_add_tcase(s32, tc32_1);
  tcase_add_test(tc32_1, strtok1);
  tcase_add_test(tc32_1, strtok2);
  tcase_add_test(tc32_1, strtok3);
  tcase_add_test(tc32_1, strtok4);
  tcase_add_test(tc32_1, strtok5);
  tcase_add_test(tc32_1, strtok6);
  tcase_add_test(tc32_1, strtok7);
  tcase_add_test(tc32_1, strtok8);
  tcase_add_test(tc32_1, strtok9);
  tcase_add_test(tc32_1, strtok10);
  tcase_add_test(tc32_1, strtok11);
  tcase_add_test(tc32_1, strtok12);
  tcase_add_test(tc32_1, strtok13);
  tcase_add_test(tc32_1, strtok14);
  tcase_add_test(tc32_1, strtok15);
  suite_add_tcase(s33, tc33_1);
  tcase_add_test(tc33_1, to_lower1);
  tcase_add_test(tc33_1, to_lower2);
  tcase_add_test(tc33_1, to_lower3);
  tcase_add_test(tc33_1, to_lower4);
  tcase_add_test(tc33_1, to_lower5);
  tcase_add_test(tc33_1, to_lower6);
  suite_add_tcase(s34, tc34_1);
  tcase_add_test(tc34_1, to_upper1);
  tcase_add_test(tc34_1, to_upper2);
  tcase_add_test(tc34_1, to_upper3);
  tcase_add_test(tc34_1, to_upper4);
  tcase_add_test(tc34_1, to_upper5);
  tcase_add_test(tc34_1, to_upper6);
  suite_add_tcase(s35, tc35_1);
  tcase_add_test(tc35_1, trim1);
  tcase_add_test(tc35_1, trim2);
  tcase_add_test(tc35_1, trim3);
  tcase_add_test(tc35_1, trim4);
  tcase_add_test(tc35_1, trim5);
  tcase_add_test(tc35_1, trim6);
  tcase_add_test(tc35_1, trim7);
  suite_add_tcase(s36, tc36_1);
  tcase_add_test(tc36_1, uitoa1);
  tcase_add_test(tc36_1, uitoa2);
  tcase_add_test(tc36_1, uitoa3);
  tcase_add_test(tc36_1, uitoa4);
  tcase_add_test(tc36_1, uitoa5);

  srunner_add_suite(sr, s2);
  srunner_add_suite(sr, s3);
  srunner_add_suite(sr, s4);
  srunner_add_suite(sr, s5);
  srunner_add_suite(sr, s6);
  srunner_add_suite(sr, s7);
  srunner_add_suite(sr, s8);
  srunner_add_suite(sr, s9);
  srunner_add_suite(sr, s10);
  srunner_add_suite(sr, s11);
  srunner_add_suite(sr, s12);
  srunner_add_suite(sr, s13);
  srunner_add_suite(sr, s14);
  srunner_add_suite(sr, s15);
  srunner_add_suite(sr, s16);
  srunner_add_suite(sr, s17);
  srunner_add_suite(sr, s18);
  srunner_add_suite(sr, s19);
  srunner_add_suite(sr, s20);
  srunner_add_suite(sr, s21);
  srunner_add_suite(sr, s22);
  srunner_add_suite(sr, s23);
  srunner_add_suite(sr, s24);
  srunner_add_suite(sr, s25);
  srunner_add_suite(sr, s26);
  srunner_add_suite(sr, s27);
  srunner_add_suite(sr, s28);
  srunner_add_suite(sr, s29);
  srunner_add_suite(sr, s30);
  srunner_add_suite(sr, s31);
  srunner_add_suite(sr, s32);
  srunner_add_suite(sr, s33);
  srunner_add_suite(sr, s34);
  srunner_add_suite(sr, s35);
  srunner_add_suite(sr, s36);

  srunner_run_all(sr, CK_ENV);
  nf = srunner_ntests_failed(sr);
  srunner_free(sr);

  return nf == 0 ? 0 : 1;
}
